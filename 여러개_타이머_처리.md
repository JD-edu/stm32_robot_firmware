
í´ëŸ­ì€ HSIë¥¼ ì‚¬ìš©í–ˆê³ , ìµœì¢…ì ìœ¼ë¡œ APB1 íƒ€ì´ë¨¸ í´ëŸ­ì€ 84MHz ì´ë‹¤. ì•„ëž˜ GPTì˜ íšŒë‹µ ì°¸ê³  
STM32ì—ì„œ ë¡œë´‡ íŽŒì›¨ì–´ë¥¼ ë§Œë“¤ê³  ìžˆì–´ìš”. íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ë¡œ 10ms 50ms 100ms ì¸í„°ëŸ½íŠ¸ë¥¼ ë°œìƒì‹œí‚¤ë ¤ê³  í•˜ëŠ”ë° ì–´ë–¤ íƒ€ì´ë¨¸ë¥¼ ì“°ë©´ ë ê¹Œìš”?
STM32F407ì—ì„œ 10ms, 50ms, 100ms ì£¼ê¸°ì˜ íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ë¥¼ ë°œìƒì‹œí‚¤ë ¤ë©´ TIM2~TIM5 ë˜ëŠ” TIM6, TIM7ê³¼ ê°™ì€ ì¼ë°˜-purpose íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ìž…ë‹ˆë‹¤.

âœ… ì‚¬ìš© ê°€ëŠ¥í•œ íƒ€ì´ë¨¸

STM32F407ì˜ íƒ€ì´ë¨¸ëŠ” í¬ê²Œ ì¼ë°˜-purpose íƒ€ì´ë¨¸ (TIM2~TIM5), ë² ì´ì§ íƒ€ì´ë¨¸ (TIM6, TIM7), ê·¸ë¦¬ê³  **ê³ ì† íƒ€ì´ë¨¸ (TIM1, TIM8)**ë¡œ ë‚˜ë‰©ë‹ˆë‹¤.
ì£¼ê¸°ì ì¸ ì¸í„°ëŸ½íŠ¸ ë°œìƒì„ ìœ„í•´ì„œëŠ” TIM2~TIM5 ë˜ëŠ” TIM6, TIM7ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì ì ˆí•©ë‹ˆë‹¤.

1ï¸âƒ£ TIM2~TIM5 (32ë¹„íŠ¸ íƒ€ì´ë¨¸, ì¼ë°˜-purpose)

- 32ë¹„íŠ¸ ì¹´ìš´í„°ì´ë¯€ë¡œ ê¸´ ì£¼ê¸°ë„ ì„¤ì • ê°€ëŠ¥
- ì£¼ íƒ€ì´ë¨¸ í´ëŸ­: 84MHz (APB1 Timer Clock)
- PSC (í”„ë¦¬ìŠ¤ì¼€ì¼ëŸ¬)ì™€ ARR (ìžë™ ë¦¬ë¡œë“œ ë ˆì§€ìŠ¤í„°)ë¥¼ ì¡°ì •í•˜ì—¬ ì›í•˜ëŠ” ì£¼ê¸°ë¡œ ì¸í„°ëŸ½íŠ¸ ìƒì„± ê°€ëŠ¥

2ï¸âƒ£ TIM6, TIM7 (16ë¹„íŠ¸ íƒ€ì´ë¨¸, ë² ì´ì§ íƒ€ì´ë¨¸)

- PWM ì—†ì´ ì¸í„°ëŸ½íŠ¸ ì „ìš©ìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥
- ì£¼ íƒ€ì´ë¨¸ í´ëŸ­: 84MHz (APB1 Timer Clock)

âœ… 10ms, 50ms, 100ms íƒ€ì´ë¨¸ ì„¤ì • ë°©ë²• (TIM2~TIM5 ì‚¬ìš©)

ðŸ’¡ 84MHz íƒ€ì´ë¨¸ í´ëŸ­ ê¸°ì¤€ìœ¼ë¡œ 10ms ì£¼ê¸°ì˜ ì¸í„°ëŸ½íŠ¸ ë°œìƒì„ ìœ„í•œ ì„¤ì • ì˜ˆì‹œ
```
// TIM2ë¥¼ ì‚¬ìš©í•œ 10ms, 50ms, 100ms íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ ì„¤ì • ì˜ˆì‹œ
void Timer_Config(void) {
    __HAL_RCC_TIM2_CLK_ENABLE(); // TIM2 í´ëŸ­ í™œì„±í™”

    TIM_HandleTypeDef htim2;
    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 8400 - 1;  // 84MHz / 8400 = 10kHz (0.1ms)
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim2.Init.Period = 100 - 1;  // 10kHz -> 100 (10ms)
    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    HAL_TIM_Base_Init(&htim2);

    HAL_TIM_Base_Start_IT(&htim2); // ì¸í„°ëŸ½íŠ¸ í™œì„±í™”

    // NVIC ì¸í„°ëŸ½íŠ¸ ì„¤ì •
    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
}

// ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ (10msë§ˆë‹¤ í˜¸ì¶œë¨)
void TIM2_IRQHandler(void) {
    if (__HAL_TIM_GET_FLAG(&htim2, TIM_FLAG_UPDATE) != RESET) {
        __HAL_TIM_CLEAR_IT(&htim2, TIM_IT_UPDATE);

        // 10ms íƒ€ì´ë¨¸ ì´ë²¤íŠ¸ ì²˜ë¦¬
    }
}

```

âœ… 50ms, 100msë„ ì‚¬ìš©í•˜ë ¤ë©´?

- ìœ„ì˜ TIM2ë¥¼ ì‚¬ìš©í•˜ì—¬ ê¸°ë³¸ì ìœ¼ë¡œ 10msë§ˆë‹¤ ì¸í„°ëŸ½íŠ¸ë¥¼ ë°œìƒì‹œí‚¤ê³ ,
- 50ms(5ë²ˆ í˜¸ì¶œë§ˆë‹¤ ì‹¤í–‰), 100ms(10ë²ˆ í˜¸ì¶œë§ˆë‹¤ ì‹¤í–‰) ì²˜ë¦¬ë¥¼ ì¶”ê°€í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
```
static uint8_t tick_50ms = 0;
static uint8_t tick_100ms = 0;

void TIM2_IRQHandler(void) {
    if (__HAL_TIM_GET_FLAG(&htim2, TIM_FLAG_UPDATE) != RESET) {
        __HAL_TIM_CLEAR_IT(&htim2, TIM_IT_UPDATE);

        // 10ms íƒ€ì´ë¨¸ ì´ë²¤íŠ¸
        tick_50ms++;
        tick_100ms++;

        if (tick_50ms >= 5) {  // 50msë§ˆë‹¤ ì‹¤í–‰
            tick_50ms = 0;
            // 50ms ì´ë²¤íŠ¸ ì‹¤í–‰
        }

        if (tick_100ms >= 10) {  // 100msë§ˆë‹¤ ì‹¤í–‰
            tick_100ms = 0;
            // 100ms ì´ë²¤íŠ¸ ì‹¤í–‰
        }
    }
}

```

âœ… TIM6 ë˜ëŠ” TIM7ì„ ì‚¬ìš©í•˜ë ¤ë©´?

- ê¸°ë³¸ íƒ€ì´ë¨¸ì¸ TIM6 ë˜ëŠ” TIM7ì„ ì‚¬ìš©í•  ìˆ˜ë„ ìžˆìŠµë‹ˆë‹¤.
- ê°™ì€ ë°©ì‹ìœ¼ë¡œ í”„ë¦¬ìŠ¤ì¼€ì¼ëŸ¬ì™€ ARRì„ ì¡°ì •í•˜ì—¬ 10msë§ˆë‹¤ ì¸í„°ëŸ½íŠ¸ë¥¼ ë°œìƒì‹œí‚¤ê³ , ì¹´ìš´í„°ë¥¼ ì´ìš©í•´ 50ms, 100ms ì²˜ë¦¬ë¥¼ í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
---

ðŸš€ ê²°ë¡ 

1. TIM2~TIM5 (32ë¹„íŠ¸ íƒ€ì´ë¨¸) ë˜ëŠ” TIM6, TIM7 (16ë¹„íŠ¸ ë² ì´ì§ íƒ€ì´ë¨¸) ì¤‘ í•˜ë‚˜ë¥¼ ì‚¬ìš©.
2. 84MHz í´ëŸ­ ê¸°ì¤€ìœ¼ë¡œ 10msë§ˆë‹¤ ì¸í„°ëŸ½íŠ¸ ë°œìƒ, ë‚´ë¶€ ì¹´ìš´í„°ë¡œ 50ms, 100ms ì²˜ë¦¬ë¥¼ ì¶”ê°€.
3. TIM2ë¥¼ ì¶”ì²œ (ë‹¤ë¥¸ íƒ€ì´ë¨¸ëŠ” PWM ë“±ê³¼ ì¶©ëŒí•  ê°€ëŠ¥ì„± ìžˆìŒ).
ì´ ë°©ë²•ìœ¼ë¡œ êµ¬í˜„í•˜ë©´ 10ms, 50ms, 100ms ê°„ê²©ìœ¼ë¡œ ì•ˆì •ì ì¸ íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ë¥¼ ë§Œë“¤ ìˆ˜ ìžˆìŠµë‹ˆë‹¤! ðŸš€

í´ëŸ­ì„ ì…‹íŒ…í•˜ê¸° 
íƒ€ì´ë¨¸í´ëŸ­ 84MHzëŠ” ì–´ë–»ê²Œ ì„¤ì •í•˜ë‚˜ìš”? HSIë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

STM32F407ì—ì„œ **HSI (ë‚´ë¶€ 16MHz ì˜¤ì‹¤ë ˆì´í„°)**ë¥¼ ì‚¬ìš©í•  ë•Œ, ì‹œìŠ¤í…œ í´ëŸ­ì„ 84MHzë¡œ ì„¤ì •í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•˜ê² ìŠµë‹ˆë‹¤.

âœ… 1. HSI ì‚¬ìš© ì‹œ ê¸°ë³¸ í´ëŸ­ ì„¤ì • ê°œìš”

- STM32F407ì˜ HSI í´ëŸ­ì€ 16MHzìž…ë‹ˆë‹¤.
- PLLì„ ì‚¬ìš©í•˜ì—¬ ì‹œìŠ¤í…œ í´ëŸ­ì„ 84MHzë¡œ ì„¤ì •í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
- APB1 ë²„ìŠ¤ (TIM2~TIM5, TIM6, TIM7 íƒ€ì´ë¨¸ê°€ ì†í•¨)ì˜ í´ëŸ­ì€ 42MHzì´ë©°, ì´ ë²„ìŠ¤ì˜ íƒ€ì´ë¨¸ëŠ” 2ë°° í´ëŸ­(=84MHz)ë¡œ ë™ìž‘í•©ë‹ˆë‹¤.
---

âœ… 2. HSI ê¸°ë°˜ 84MHz ì„¤ì • ë°©ë²• (PLL ì‚¬ìš©)

ì‹œìŠ¤í…œ í´ëŸ­ì„ 84MHzë¡œ ì„¤ì •í•˜ë ¤ë©´ ë‹¤ìŒê³¼ ê°™ì´ PLL ì„¤ì •ì„ í•©ë‹ˆë‹¤.
ì„¤ì •ê°’
ì„¤ëª…
HSI (16MHz)
ê¸°ë³¸ ë‚´ë¶€ ì˜¤ì‹¤ë ˆì´í„°
PLLM = 16
PLL ìž…ë ¥ í´ëŸ­ì„ 1MHzë¡œ ë§Œë“¦ (16MHz / 16 = 1MHz)
PLLN = 168
PLL ì£¼íŒŒìˆ˜ë¥¼ 168MHzë¡œ ì¦í­ (1MHz Ã— 168 = 168MHz)
PLLP = 2
ì‹œìŠ¤í…œ í´ëŸ­ì„ 84MHzë¡œ ì„¤ì • (168MHz / 2 = 84MHz)
PLLQ = 7
USB í´ëŸ­ ì„¤ì • (ì‚¬ìš©í•˜ì§€ ì•Šì•„ë„ ë¨)

---

âœ… 3. ì½”ë“œ ì˜ˆì œ (HSI â†’ 84MHz ì‹œìŠ¤í…œ í´ëŸ­ ì„¤ì •)

ì•„ëž˜ëŠ” HSIë¥¼ ì‚¬ìš©í•˜ì—¬ PLLì„ ì„¤ì •í•˜ê³ , ì‹œìŠ¤í…œ í´ëŸ­ì„ 84MHzë¡œ ì„¤ì •í•˜ëŠ” ì½”ë“œìž…ë‹ˆë‹¤.
```
void SystemClock_Config(void) {
    // ì „ì› í´ëŸ­ í™œì„±í™”
    __HAL_RCC_PWR_CLK_ENABLE();

    // ì „ì•• ì¡°ì •: ì„±ëŠ¥ ëª¨ë“œë¥¼ ìœ„í•´ ì¡°ì • (3.3Vì—ì„œ ìµœì  ì„±ëŠ¥)
    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

    // HSIë¥¼ ì‚¬ìš©í•˜ë„ë¡ ì„¤ì •
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
    RCC_OscInitStruct.HSIState = RCC_HSI_ON;  // HSI í™œì„±í™”
    RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
    RCC_OscInitStruct.PLL.PLLM = 16;
    RCC_OscInitStruct.PLL.PLLN = 168;
    RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;  // SYSCLK = 168MHz / 2 = 84MHz
    RCC_OscInitStruct.PLL.PLLQ = 7;  // USB, SDIO, RNG í´ëŸ­

    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
        // ì˜¤ë¥˜ ì²˜ë¦¬
        while (1);
    }

    // ë²„ìŠ¤ í´ëŸ­ ì„¤ì •
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK |
                                  RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;  // 84MHz
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;   // 42MHz (APB1)
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;   // 84MHz (APB2)

    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) {
        // ì˜¤ë¥˜ ì²˜ë¦¬
        while (1);
    }

    // Systick ì„¤ì • (1ms ë‹¨ìœ„ íƒ€ì´ë¨¸)
    HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / 1000);
    HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
}

```

---

âœ… 4. íƒ€ì´ë¨¸ í´ëŸ­ í™•ì¸

ì‹œìŠ¤í…œ í´ëŸ­ì´ ì •ìƒì ìœ¼ë¡œ ì„¤ì •ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ë°©ë²•ìž…ë‹ˆë‹¤.
```
// í˜„ìž¬ í´ëŸ­ ì£¼íŒŒìˆ˜ë¥¼ í™•ì¸í•˜ëŠ” ì½”ë“œ
void Check_Clock_Frequencies() {
    uint32_t sysclk = HAL_RCC_GetSysClockFreq();   // SYSCLK (84MHz ì˜ˆìƒ)
    uint32_t hclk = HAL_RCC_GetHCLKFreq();         // AHB í´ëŸ­ (84MHz)
    uint32_t pclk1 = HAL_RCC_GetPCLK1Freq();       // APB1 í´ëŸ­ (42MHz)
    uint32_t pclk2 = HAL_RCC_GetPCLK2Freq();       // APB2 í´ëŸ­ (84MHz)

    printf("SYSCLK: %lu Hz\n", sysclk);
    printf("HCLK: %lu Hz\n", hclk);
    printf("PCLK1: %lu Hz\n", pclk1);
    printf("PCLK2: %lu Hz\n", pclk2);
}

```

---

âœ… 5. íƒ€ì´ë¨¸ í´ëŸ­ (TIM2~TIM5, TIM6, TIM7)

- APB1 í´ëŸ­ = 42MHz
- APB1 íƒ€ì´ë¨¸ (TIM2~TIM5, TIM6, TIM7) í´ëŸ­ = 84MHz (APB1 íƒ€ì´ë¨¸ëŠ” 2ë°° ì†ë„)
ì´ì œ íƒ€ì´ë¨¸ë¥¼ ì„¤ì •í•˜ë©´ 84MHz íƒ€ì´ë¨¸ í´ëŸ­ì„ ì‚¬ìš©í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
ì˜ˆì œ:
```
htim2.Init.Prescaler = 8400 - 1;  // 84MHz / 8400 = 10kHz (0.1ms)
htim2.Init.Period = 100 - 1;      // 100 * 0.1ms = 10ms ì£¼ê¸° ì¸í„°ëŸ½íŠ¸

```

---

ðŸš€ ê²°ë¡ 

- HSI (16MHz) â†’ PLL ì„¤ì • â†’ ì‹œìŠ¤í…œ í´ëŸ­ 84MHzë¡œ ì„¤ì • ê°€ëŠ¥
- APB1 (TIM2~TIM5, TIM6, TIM7) í´ëŸ­ = 42MHz, íƒ€ì´ë¨¸ í´ëŸ­ = 84MHz
- íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ëŠ” ìœ„ ì„¤ì •ì„ ê¸°ë°˜ìœ¼ë¡œ ì›í•˜ëŠ” ì£¼ê¸°ë¡œ ì„¤ì • ê°€ëŠ¥.
ì´ì œ ì›í•˜ëŠ” 10ms, 50ms, 100ms íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤! ðŸŽ¯


STM32ì—ì„œ 10ms 50ms 100ms ì¸í„°ëŸ½íŠ¸ë¥¼ ë°œìƒí•  ë–¼, ê°ê°ì˜ íƒ€ì´ë¨¸ë¥¼ ì“°ëŠ” ê²ƒì´ ë‚«ë‚˜ìš”? ì•„ë‹ˆë©´ í•œê°œì˜ íƒ€ì´ë¨¸ì— ë³€ìˆ˜ë¥¼ ë‘ì–´ì„œ ë¶„ê¸°í•˜ëŠ” ê²ƒì´ ë‚«ë‚˜ìš”?

STM32ì—ì„œ 10ms, 50ms, 100ms ì£¼ê¸°ë¡œ ì¸í„°ëŸ½íŠ¸ë¥¼ ë°œìƒì‹œí‚¤ëŠ” ë°©ë²•ìœ¼ë¡œ ë‘ ê°€ì§€ ë°©ë²•ì„ ë¹„êµí•´ ë³´ê² ìŠµë‹ˆë‹¤.
1. ê°ê°ì˜ íƒ€ì´ë¨¸(TIM) ì‚¬ìš©
2. í•˜ë‚˜ì˜ íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•˜ê³  ë³€ìˆ˜ë¡œ ë¶„ê¸°

âœ… 1. ê°ê°ì˜ íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•

STM32ì˜ ì—¬ëŸ¬ ê°œì˜ TIMì„ ì‚¬ìš©í•˜ì—¬ ê°ê°ì˜ ì£¼ê¸°ë¥¼ ì„¤ì •í•˜ëŠ” ë°©ë²•ìž…ë‹ˆë‹¤.

ìž¥ì 

- ë…ë¦½ì ì¸ íƒ€ì´ë¨¸ ë™ìž‘ â†’ ê°„ì„­ì´ ì—†ìŒ.
- ì •í™•í•œ ì£¼ê¸° ë³´ìž¥ â†’ ë‹¤ë¥¸ ì£¼ê¸°ì˜ ì˜í–¥ì„ ë°›ì§€ ì•ŠìŒ.
- ë” ì§ê´€ì ì¸ ì½”ë“œ â†’ íŠ¹ì • íƒ€ì´ë¨¸ê°€ íŠ¹ì • ì£¼ê¸°ë¥¼ ë‹´ë‹¹.

ë‹¨ì 

- TIM ë¦¬ì†ŒìŠ¤ ì‚¬ìš© ì¦ê°€ â†’ TIMì„ ë§Žì´ ì‚¬ìš©í•˜ë©´ ë‹¤ë¥¸ ê¸°ëŠ¥ì„ ì¶”ê°€í•˜ê¸° ì–´ë ¤ì›€.
- ì „ë ¥ ì†Œë¹„ ì¦ê°€ (ì €ì „ë ¥ ì‹œìŠ¤í…œì—ì„œëŠ” ë¬¸ì œê°€ ë  ìˆ˜ë„ ìžˆìŒ).

ì˜ˆì œ ì½”ë“œ

```
void MX_TIM2_Init(void) {  // 10ms íƒ€ì´ë¨¸
    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 7999;  // 8MHz / (7999 + 1) = 1kHz
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim2.Init.Period = 9;  // 10ms (1kHz * 10ms = 10)
    HAL_TIM_Base_Init(&htim2);
    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
}

void MX_TIM3_Init(void) {  // 50ms íƒ€ì´ë¨¸
    htim3.Instance = TIM3;
    htim3.Init.Prescaler = 7999;
    htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim3.Init.Period = 49;  // 50ms
    HAL_TIM_Base_Init(&htim3);
    HAL_NVIC_SetPriority(TIM3_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(TIM3_IRQn);
}

void MX_TIM4_Init(void) {  // 100ms íƒ€ì´ë¨¸
    htim4.Instance = TIM4;
    htim4.Init.Prescaler = 7999;
    htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim4.Init.Period = 99;  // 100ms
    HAL_TIM_Base_Init(&htim4);
    HAL_NVIC_SetPriority(TIM4_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(TIM4_IRQn);
}

void TIM2_IRQHandler(void) {
    HAL_TIM_IRQHandler(&htim2);
}

void TIM3_IRQHandler(void) {
    HAL_TIM_IRQHandler(&htim3);
}

void TIM4_IRQHandler(void) {
    HAL_TIM_IRQHandler(&htim4);
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
    if (htim->Instance == TIM2) {
        // 10ms ìž‘ì—… ìˆ˜í–‰
    } else if (htim->Instance == TIM3) {
        // 50ms ìž‘ì—… ìˆ˜í–‰
    } else if (htim->Instance == TIM4) {
        // 100ms ìž‘ì—… ìˆ˜í–‰
    }
}

```

---

âœ… 2. í•˜ë‚˜ì˜ íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•˜ê³  ë³€ìˆ˜ë¡œ ë¶„ê¸°í•˜ëŠ” ë°©ë²•

í•œ ê°œì˜ íƒ€ì´ë¨¸ë¥¼ ì„¤ì •í•˜ì—¬ ìµœì†Œ ì£¼ê¸°(ì˜ˆ: 10ms)ë¡œ ì¸í„°ëŸ½íŠ¸ë¥¼ ë°œìƒì‹œí‚¤ê³ , ë³€ìˆ˜ ì¹´ìš´íŠ¸ë¥¼ í†µí•´ 50ms, 100ms ìž‘ì—…ì„ ë¶„ê¸°í•˜ëŠ” ë°©ë²•ìž…ë‹ˆë‹¤.

ìž¥ì 

- íƒ€ì´ë¨¸ ìžì›ì„ ì ê²Œ ì‚¬ìš© â†’ TIMì„ í•˜ë‚˜ë§Œ ì‚¬ìš©.
- ì¼ì •í•œ ì£¼ê¸°ë¡œ ì—¬ëŸ¬ ì£¼ê¸° ê´€ë¦¬ ê°€ëŠ¥.
- ì½”ë“œê°€ ë‹¨ìˆœí•´ì§ â†’ ì—¬ëŸ¬ ê°œì˜ íƒ€ì´ë¨¸ë¥¼ ì„¤ì •í•  í•„ìš” ì—†ìŒ.

ë‹¨ì 

- ì¸í„°ëŸ½íŠ¸ì—ì„œ ì¶”ê°€ ì—°ì‚° í•„ìš” (ë³€ìˆ˜ë¥¼ ì¦ê°€ì‹œí‚¤ê³  ì¡°ê±´ë¬¸ í™•ì¸).
- ì¸í„°ëŸ½íŠ¸ì˜ ì‹¤í–‰ ì‹œê°„ì´ ê¸¸ì–´ì§ˆ ìˆ˜ ìžˆìŒ (ìž‘ì—…ëŸ‰ì´ ë§Žì•„ì§€ë©´ ë¶€ë‹´ë  ìˆ˜ ìžˆìŒ).
- íƒ€ì´ë¨¸ì˜ ê¸°ë³¸ ì£¼ê¸°ê°€ ë„ˆë¬´ í¬ë©´ ì •ë°€ë„ ì €í•˜ (10ms ì£¼ê¸°ë¡œ 1ms ë‹¨ìœ„ë¥¼ ë‹¤ë£¨ë ¤ë©´ ì–´ë µë‹¤).

ì˜ˆì œ ì½”ë“œ

```
volatile uint32_t timer_counter = 0;

void MX_TIM2_Init(void) {  // 10ms ë‹¨ìœ„ íƒ€ì´ë¨¸
    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 7999;  // 8MHz / (7999 + 1) = 1kHz
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim2.Init.Period = 9;  // 10ms (1kHz * 10ms = 10)
    HAL_TIM_Base_Init(&htim2);
    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
}

void TIM2_IRQHandler(void) {
    HAL_TIM_IRQHandler(&htim2);
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
    if (htim->Instance == TIM2) {
        timer_counter++;

        // 10msë§ˆë‹¤ ì‹¤í–‰
        Do10msTask();

        // 50msë§ˆë‹¤ ì‹¤í–‰
        if (timer_counter % 5 == 0) {
            Do50msTask();
        }

        // 100msë§ˆë‹¤ ì‹¤í–‰
        if (timer_counter % 10 == 0) {
            Do100msTask();
        }
        
        if (timer_counter >= 1000) {  // ì˜¤ë²„í”Œë¡œìš° ë°©ì§€ (1000 * 10ms = 10s)
            timer_counter = 0;
        }
    }
}

void Do10msTask(void) {
    HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
}

void Do50msTask(void) {
    // 50ms ì£¼ê¸° ìž‘ì—…
}

void Do100msTask(void) {
    // 100ms ì£¼ê¸° ìž‘ì—…
}

```

---

âœ… ì–´ë–¤ ë°©ë²•ì´ ë” ì¢‹ì„ê¹Œ?


âš¡ ê° íƒ€ì´ë¨¸ë¥¼ ë”°ë¡œ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ì€ ê²½ìš°

âœ” ì •í™•í•œ ì£¼ê¸°ê°€ í•„ìš”í•  ë•Œ (ì˜ˆ: PWM ì‹ í˜¸ ìƒì„±, ê³ ì •ëœ ìƒ˜í”Œë§ ì£¼ê¸°)
âœ” ì—¬ëŸ¬ ê°œì˜ íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìžˆì„ ë•Œ (STM32 íƒ€ì´ë¨¸ê°€ ì¶©ë¶„í•  ë•Œ)
âœ” ì¸í„°ëŸ½íŠ¸ ë¶€í•˜ë¥¼ ìµœì†Œí™”í•˜ê³  ì‹¶ì„ ë•Œ

âš¡ í•œ ê°œì˜ íƒ€ì´ë¨¸ë¡œ ë¶„ê¸°í•˜ëŠ” ê²ƒì´ ì¢‹ì€ ê²½ìš°

âœ” íƒ€ì´ë¨¸ ë¦¬ì†ŒìŠ¤ë¥¼ ì•„ë¼ê³  ì‹¶ì„ ë•Œ (STM32ì—ì„œ TIMì´ ë¶€ì¡±í•  ë•Œ)
âœ” ë‹¨ìˆœí•œ ì½”ë“œ ìœ ì§€ê°€ í•„ìš”í•  ë•Œ
âœ” ë‚®ì€ ì£¼íŒŒìˆ˜(10ms ì´ìƒ)ì—ì„œ ë™ìž‘í•  ë•Œ (ë³€ìˆ˜ ê³„ì‚° ë¶€í•˜ê°€ í¬ì§€ ì•ŠìŒ)
---

ê²°ë¡ 

1. ê°ê°ì˜ íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì€ ë³´ë‹¤ ì •í™•í•œ ì£¼ê¸°ë¥¼ ë³´ìž¥í•˜ì§€ë§Œ, TIM ìžì›ì„ ë§Žì´ ì‚¬ìš©í•©ë‹ˆë‹¤.
2. í•œ ê°œì˜ íƒ€ì´ë¨¸ì—ì„œ ë³€ìˆ˜ë¥¼ í†µí•´ ë¶„ê¸°í•˜ëŠ” ë°©ë²•ì€ TIM ìžì›ì„ ì•„ë‚„ ìˆ˜ ìžˆì§€ë§Œ, ë³€ìˆ˜ë¥¼ í™•ì¸í•˜ëŠ” ì—°ì‚° ë¶€í•˜ê°€ ì•½ê°„ ë°œìƒí•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
ë§Œì•½ íƒ€ì´ë¨¸ ë¦¬ì†ŒìŠ¤ê°€ ì¶©ë¶„í•˜ë‹¤ë©´ ê°ê°ì˜ íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì •í™•ë„ê°€ ë” ë†’ê³  ê°„ì„­ì„ ì¤„ì¼ ìˆ˜ ìžˆì–´ ìœ ë¦¬í•©ë‹ˆë‹¤.
ê·¸ëŸ¬ë‚˜ íƒ€ì´ë¨¸ë¥¼ ë§Žì´ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ê²½ìš°, í•œ ê°œì˜ íƒ€ì´ë¨¸ë¡œ ë¶„ê¸°í•˜ëŠ” ê²ƒì´ íš¨ìœ¨ì ì¸ í•´ê²°ì±…ì´ ë  ìˆ˜ ìžˆìŠµë‹ˆë‹¤. ðŸš€

I2C í†µì‹ ë¬¸ì œ
ì„  ë¬¼ì•ˆì´ ì›ì¸ ì¸ ë“¯ .... í•˜ì—¬ê°„ HAL_OK ì²´í¬í•´ì„œ í•˜ë“œì›¨ì–´ ë¬¸ì œ ìƒê¸´ ê²ƒì€ ì°¾ì„ ìˆ˜ ìžˆì—ˆë‹¤. 

íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•˜ì—¬ MPU6050 IMU ì„¼ì„œë¥¼ ì£¼ê¸°ì ìœ¼ë¡œ ì½ì„ ë•Œ, ê°’ì´ ê³ ì •ë˜ê±°ë‚˜ ì´ìƒí•œ ê°’ì´ ì¶œë ¥ë˜ëŠ” ë¬¸ì œëŠ” ì—¬ëŸ¬ ê°€ì§€ ì›ì¸ìœ¼ë¡œ ì¸í•´ ë°œìƒí•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤. ì£¼ìš” ì›ì¸ì„ ë¶„ì„í•˜ê³  í•´ê²°ì±…ì„ ì œì‹œí•˜ê² ìŠµë‹ˆë‹¤.
---

1. I2C í†µì‹  ë¬¸ì œ


ì›ì¸

- I2C í†µì‹ ì´ ì œëŒ€ë¡œ ì´ë£¨ì–´ì§€ì§€ ì•Šìœ¼ë©´, MPU6050ì—ì„œ ì´ì „ ë°ì´í„°ë¥¼ ê³„ì† ë°˜í™˜í•˜ê±°ë‚˜ 0 ê°’ì„ ë³´ë‚¼ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
- MPU6050ì˜ ì „ì›ì´ ì¶©ë¶„í•˜ì§€ ì•Šê±°ë‚˜, I2C ë¼ì¸ì—ì„œ í’€ì—… ì €í•­ì´ ì—†ìœ¼ë©´ ì •ìƒì ì¸ ë°ì´í„° ì „ì†¡ì´ ì´ë£¨ì–´ì§€ì§€ ì•Šì„ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.

í•´ê²°ì±…

- í’€ì—… ì €í•­ í™•ì¸: I2C SDA/SCL ë¼ì¸ì— 4.7kÎ©~10kÎ© í’€ì—… ì €í•­ì´ ì—°ê²°ë˜ì–´ ìžˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.
- ì „ì•• í™•ì¸: MPU6050ì´ 3.3V ë˜ëŠ” 5Vì—ì„œ ì •ìƒ ë™ìž‘í•˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.
- I2C ìƒíƒœ í™•ì¸: HAL ìƒíƒœ ê°’ì„ í™•ì¸í•˜ì—¬ HAL_I2C_Master_Transmit() ë˜ëŠ” HAL_I2C_Master_Receive()ê°€ HAL_OKë¥¼ ë°˜í™˜í•˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.
  
- WHO_AM_I í™•ì¸: Read_MPU6050_ID() í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ì—¬ ì œëŒ€ë¡œ 0x68 ë˜ëŠ” 0x69 ê°’ì„ ë°˜í™˜í•˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.
---

2. íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ì—ì„œì˜ IMU ë°ì´í„° ì½ê¸° ë¬¸ì œ


ì›ì¸

- íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ëŠ” ì£¼ê¸°ì ìœ¼ë¡œ ë°œìƒí•˜ì§€ë§Œ, I2C í†µì‹ ì€ ë¹„êµì  ëŠë¦° ìž‘ì—…ì´ë¯€ë¡œ ì¸í„°ëŸ½íŠ¸ì—ì„œ ì‹¤í–‰í•˜ë©´ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
- I2C í†µì‹ ì´ ì§„í–‰ ì¤‘ì¸ë° ë‹¤ì‹œ ì¸í„°ëŸ½íŠ¸ê°€ ë°œìƒí•˜ë©´ I2C ìƒíƒœê°€ ê¹¨ì§ˆ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
- f_imu_read = 1; í”Œëž˜ê·¸ë¥¼ ì„¤ì •í–ˆì§€ë§Œ, ë©”ì¸ ë£¨í”„ì—ì„œ ì²˜ë¦¬í•˜ê¸° ì „ì— ê°’ì´ ë®ì–´ì”Œì›Œì§ˆ ê°€ëŠ¥ì„±ì´ ìžˆìŠµë‹ˆë‹¤.

í•´ê²°ì±…

- ì¸í„°ëŸ½íŠ¸ì—ì„œ ì§ì ‘ I2C ì½ì§€ ì•Šê¸°
  í˜„ìž¬ ì½”ë“œëŠ” HAL_TIM_PeriodElapsedCallback()ì—ì„œ f_imu_read = 1;ì„ ì„¤ì •í•œ í›„ ë©”ì¸ ë£¨í”„ì—ì„œ I2C ì½ê¸°ë¥¼ ìˆ˜í–‰í•˜ëŠ” ë°©ì‹ìž…ë‹ˆë‹¤.
  ê·¸ëŸ¬ë‚˜, HAL_I2C_Master_Transmit() ë˜ëŠ” HAL_I2C_Master_Receive()ë¥¼ ì¸í„°ëŸ½íŠ¸ì—ì„œ ì§ì ‘ í˜¸ì¶œí•˜ëŠ” ê²ƒì€ ë§¤ìš° ìœ„í—˜í•©ë‹ˆë‹¤.
  ì˜¬ë°”ë¥¸ ë°©ë²•:
  ê·¸ë¦¬ê³  ë©”ì¸ ë£¨í”„ì—ì„œ ì²˜ë¦¬í•  ë•Œ:
---

3. I2C í†µì‹  ì†ë„ ë¬¸ì œ


ì›ì¸

- I2C ì†ë„ê°€ ë„ˆë¬´ ë¹ ë¥´ë©´ MPU6050ì´ ë°ì´í„°ë¥¼ ì œëŒ€ë¡œ ì œê³µí•˜ì§€ ëª»í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
- í˜„ìž¬ ClockSpeed = 100000 (100kHz)ë¡œ ì„¤ì •ë˜ì–´ ìžˆì§€ë§Œ, ì¼ë¶€ ì„¼ì„œì—ì„œëŠ” ë” ë‚®ì€ ì†ë„ë¥¼ ìš”êµ¬í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.

í•´ê²°ì±…

- ì†ë„ë¥¼ ë‚®ì¶°ì„œ í…ŒìŠ¤íŠ¸í•´ë³´ì„¸ìš”: 
  ë§Œì•½ ì†ë„ë¥¼ 50kHzë¡œ ë‚®ì¶˜ í›„ ì •ìƒ ìž‘ë™í•˜ë©´, 100kHzì—ì„œ ë¬¸ì œê°€ ë°œìƒí–ˆì„ ê°€ëŠ¥ì„±ì´ í½ë‹ˆë‹¤.
---

4. MPU6050ì˜ ì´ˆê¸°í™” ë¬¸ì œ


ì›ì¸

- MPU6050_Init()ì—ì„œ PWR_MGMT_1ì„ 0x00ìœ¼ë¡œ ì„¤ì •í•˜ëŠ” ê²ƒ ì™¸ì—ë„, ê¸°ë³¸ì ìœ¼ë¡œ MPU6050ì´ ë™ìž‘í•˜ê¸° ìœ„í•´ ëª‡ ê°€ì§€ ì„¤ì •ì´ í•„ìš”í•©ë‹ˆë‹¤.

í•´ê²°ì±…

- MPU6050_Init()ì„ ì•„ëž˜ì²˜ëŸ¼ ìˆ˜ì •í•´ë³´ì„¸ìš”:
  
	- ì¤‘ìš”í•œ ì ì€ ì„¤ì • ê°„ì˜ HAL_Delay(10);ì„ ë°˜ë“œì‹œ ë„£ì–´ì•¼ í•œë‹¤ëŠ” ê²ƒìž…ë‹ˆë‹¤.
	- CONFIG ë ˆì§€ìŠ¤í„°ë¥¼ ì„¤ì •í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.
---

5. MPU6050ì´ ìŠ¬ë¦½ ëª¨ë“œì—ì„œ ë²—ì–´ë‚˜ì§€ ì•ŠìŒ


ì›ì¸

- PWR_MGMT_1 = 0x00ì„ ì„¤ì •í•˜ëŠ” ê²ƒì´ MPU6050ì„ ìŠ¬ë¦½ ëª¨ë“œì—ì„œ ê¹¨ìš°ëŠ” ë™ìž‘ì´ì§€ë§Œ, ì¼ë¶€ ë³´ë“œì—ì„œëŠ” ì¶”ê°€ ì„¤ì •ì´ í•„ìš”í•©ë‹ˆë‹¤.

í•´ê²°ì±…

- MPU6050_Init()ì—ì„œ ë‹¤ìŒì„ ì¶”ê°€í•˜ì„¸ìš”:
  
	- 0x00ì´ ì•„ë‹ˆë¼ 0x01ë¡œ ì„¤ì •í•˜ë©´ ë” ì•ˆì •ì ì¸ ë™ìž‘ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.
---

6. IMU ë°ì´í„°ê°€ ì œëŒ€ë¡œ ë³€í•˜ëŠ”ì§€ í™•ì¸í•˜ëŠ” ë°©ë²•


í•´ê²°ì±…

- UARTë¥¼ í†µí•´ ë°ì´í„°ë¥¼ ì¶œë ¥í•´ë³´ì„¸ìš”: 
- ë°ì´í„°ë¥¼ ì¶œë ¥í•˜ë©´ì„œ IMUë¥¼ ì›€ì§ì´ë©´ ê°’ì´ ë³€í•˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.
---

ê²°ë¡ 

âœ… í™•ì¸í•´ì•¼ í•  ì‚¬í•­
1. I2C í†µì‹  ë¬¸ì œ í•´ê²° (í’€ì—… ì €í•­, ì „ì› í™•ì¸, WHO_AM_I ì²´í¬)
2. íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ì—ì„œ I2C ì§ì ‘ í˜¸ì¶œí•˜ì§€ ì•Šê¸°
3. I2C ì†ë„ë¥¼ 50kHzë¡œ ë‚®ì¶° í…ŒìŠ¤íŠ¸
4. MPU6050 ì´ˆê¸°í™” ê³¼ì • ê°œì„ 
5. MPU6050 ìŠ¬ë¦½ ëª¨ë“œ í•´ì œ ì„¤ì • ì¶”ê°€
6. UARTë¡œ ê°’ì´ ë³€í•˜ëŠ”ì§€ í™•ì¸
ì´ ë°©ë²•ì„ ì ìš©í•˜ë©´ íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•˜ë”ë¼ë„ MPU6050ì—ì„œ ì˜¬ë°”ë¥¸ ë°ì´í„°ë¥¼ ì½ì„ ìˆ˜ ìžˆì„ ê²ƒìž…ë‹ˆë‹¤. ðŸš€

ì´ ì½”ë“œëŠ” STM32ë¡œ MPU6050ì„ ì½ì–´ì„œ ì‹œë¦¬ì–¼ë¡œ ë³´ë‚´ëŠ” ì½”ë“œ ìž…ë‹ˆë‹¤. ì—¬ê¸°ì— ìƒë³´í•„í„°ë¥¼ ë„£ì–´ì„œ pitch roll yawë¥¼ ì–»ëŠ” ì½”ë“œë¥¼ ì¶”ê°€í•´ ì£¼ì„¸ìš”. pitch roll yawëŠ” 2ë°”ì´íŠ¸ ì •ìˆ˜ë¡œ ë°”ê¿”ì„œ ìžì´ë¡œ ë’¤ì— ë°”ì´íŠ¸ ì–´ë ˆì´ ì¶”ê°€í•´ ì£¼ì„¸ìš”

ì—¬ê¸°ì— ìƒë³´ í•„í„°(Complementary Filter)ë¥¼ ì ìš©í•˜ì—¬ pitch, roll, yawë¥¼ ê³„ì‚°í•˜ê³ , ê¸°ì¡´ì˜ ê°€ì†ë„ ë° ìžì´ë¡œ ë°ì´í„°ë¥¼ ì „ì†¡í•˜ëŠ” ì½”ë“œì— ì¶”ê°€í•˜ê² ìŠµë‹ˆë‹¤.
- pitch, rollì€ ê°€ì†ë„ê³„ì™€ ìžì´ë¡œìŠ¤ì½”í”„ ë°ì´í„°ë¥¼ ì¡°í•©í•˜ì—¬ ê³„ì‚°í•©ë‹ˆë‹¤.
- yawëŠ” ìžì´ë¡œìŠ¤ì½”í”„ ë°ì´í„°ë¥¼ ì ë¶„í•˜ì—¬ ê³„ì‚°í•©ë‹ˆë‹¤.
- ìµœì¢…ì ìœ¼ë¡œ 2ë°”ì´íŠ¸ ì •ìˆ˜ ê°’ìœ¼ë¡œ ë³€í™˜í•˜ì—¬ ì‹œë¦¬ì–¼ë¡œ ì „ì†¡í•©ë‹ˆë‹¤.
---

ë³€ê²½ ì‚¬í•­

âœ… ìƒë³´ í•„í„° ì ìš©í•˜ì—¬ pitch, roll, yaw ê³„ì‚°
âœ… 2ë°”ì´íŠ¸ ì •ìˆ˜ ë³€í™˜ í›„ ê¸°ì¡´ ë°ì´í„° íŒ¨í‚·ì— ì¶”ê°€í•˜ì—¬ ì „ì†¡
âœ… Yaw drift ë³´ì •ì„ ìœ„í•´ ê°„ë‹¨í•œ ë³´ì • ë¡œì§ í¬í•¨
âœ… TIM2 ì¸í„°ëŸ½íŠ¸(ê¸°ì¡´ IMU ì—…ë°ì´íŠ¸ ì£¼ê¸°)ì—ì„œ ì—…ë°ì´íŠ¸
---

ë³€ê²½ëœ ì½”ë“œ

```
/* USER CODE BEGIN PV */
char f_imu_read = 0;
char f_uart_send = 0;
uint8_t who_am_i = 0;
int16_t ax, ay, az;
int16_t gx, gy, gz;
int16_t pitch, roll, yaw;

float pitch_f = 0.0, roll_f = 0.0, yaw_f = 0.0;
float alpha = 0.98;  // ìƒë³´ í•„í„° ê³„ìˆ˜
float dt = 0.01;     // ìƒ˜í”Œë§ ì£¼ê¸° (100Hz ê¸°ì¤€)
/* USER CODE END PV */

/* USER CODE BEGIN 4 */
// ìƒë³´ í•„í„° ì ìš©í•˜ì—¬ pitch, roll, yaw ê³„ì‚°
void Compute_Orientation() {
    // ê°€ì†ë„ê³„ ê¸°ë°˜ pitch, roll ê³„ì‚°
    float acc_pitch = atan2(-ax, sqrt(ay * ay + az * az)) * 57.2958; // rad to deg
    float acc_roll  = atan2(ay, az) * 57.2958;

    // ìžì´ë¡œìŠ¤ì½”í”„ ë°ì´í„°ë¥¼ ê°ì†ë„(Â°/s)ë¡œ ë³€í™˜ (MPU6050 ê¸°ë³¸ ê°ë„: 250dps)
    float gx_dps = gx / 131.0;
    float gy_dps = gy / 131.0;
    float gz_dps = gz / 131.0;

    // ìƒë³´ í•„í„° ì ìš©
    pitch_f = alpha * (pitch_f + gy_dps * dt) + (1 - alpha) * acc_pitch;
    roll_f = alpha * (roll_f + gx_dps * dt) + (1 - alpha) * acc_roll;
    yaw_f += gz_dps * dt; // YawëŠ” ìžì´ë¡œë§Œ ì‚¬ìš©

    // float ê°’ì„ int16_të¡œ ë³€í™˜
    pitch = (int16_t)(pitch_f * 100);
    roll = (int16_t)(roll_f * 100);
    yaw = (int16_t)(yaw_f * 100);
}

// IMU ë°ì´í„° ë° Orientation ì „ì†¡
void Send_IMU_Data(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz, int16_t* pitch, int16_t* roll, int16_t* yaw) {
    uint8_t tx_buffer[18];

    // 16ë¹„íŠ¸ ì •ìˆ˜ ê°’ì„ ë°”ì´íŠ¸ ë°°ì—´ë¡œ ë³€í™˜ (Little Endian)
    tx_buffer[0] = *ax & 0xFF;
    tx_buffer[1] = (*ax >> 8) & 0xFF;
    tx_buffer[2] = *ay & 0xFF;
    tx_buffer[3] = (*ay >> 8) & 0xFF;
    tx_buffer[4] = *az & 0xFF;
    tx_buffer[5] = (*az >> 8) & 0xFF;
    tx_buffer[6] = *gx & 0xFF;
    tx_buffer[7] = (*gx >> 8) & 0xFF;
    tx_buffer[8] = *gy & 0xFF;
    tx_buffer[9] = (*gy >> 8) & 0xFF;
    tx_buffer[10] = *gz & 0xFF;
    tx_buffer[11] = (*gz >> 8) & 0xFF;
    tx_buffer[12] = *pitch & 0xFF;
    tx_buffer[13] = (*pitch >> 8) & 0xFF;
    tx_buffer[14] = *roll & 0xFF;
    tx_buffer[15] = (*roll >> 8) & 0xFF;
    tx_buffer[16] = *yaw & 0xFF;
    tx_buffer[17] = (*yaw >> 8) & 0xFF;

    // UART ì „ì†¡
    HAL_UART_Transmit(&huart2, tx_buffer, 18, 100);
}

// ì£¼ê¸°ì ì¸ IMU ì—…ë°ì´íŠ¸ (TIM2 ì¸í„°ëŸ½íŠ¸ ì‚¬ìš©)
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
    if (htim->Instance == TIM2) {
        f_imu_read = 1;
    } else if (htim->Instance == TIM3) {
        f_uart_send = 1;
    }
}

int main(void) {
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_I2C1_Init();
    MX_USART2_UART_Init();
    MX_TIM2_Init();
    MX_TIM3_Init();
    MX_NVIC_Init();

    HAL_TIM_Base_Start_IT(&htim2);
    HAL_TIM_Base_Start_IT(&htim3);
    MPU6050_Init();

    while (1) {
        if (f_imu_read == 1) {
            MPU6050_ReadAccel(&ax, &ay, &az);
            MPU6050_ReadGyro(&gx, &gy, &gz);
            Compute_Orientation();
            f_imu_read = 0;
        }
        if (f_uart_send == 1) {
            Send_IMU_Data(&ax, &ay, &az, &gx, &gy, &gz, &pitch, &roll, &yaw);
            f_uart_send = 0;
        }
    }
}

```

---

ë³€ê²½ëœ ë°ì´í„° ì „ì†¡ í¬ë§·

Byte Index
Data
0-1
Accel X (int16)
2-3
Accel Y (int16)
4-5
Accel Z (int16)
6-7
Gyro X (int16)
8-9
Gyro Y (int16)
10-11
Gyro Z (int16)
12-13
Pitch (int16)
14-15
Roll (int16)
16-17
Yaw (int16)

---

ì ìš©ëœ ê°œì„ ì 

1. âœ… ìƒë³´ í•„í„° ì¶”ê°€ â†’ ë…¸ì´ì¦ˆ ì œê±° ë° ë” ì•ˆì •ì ì¸ Orientation ê³„ì‚°
2. âœ… Yaw drift ë°©ì§€ â†’ ê°„ë‹¨í•œ ë³´ì • ë°©ì‹ ì ìš©
3. âœ… 2ë°”ì´íŠ¸ ì •ìˆ˜ë¡œ ë³€í™˜í•˜ì—¬ ì „ì†¡ â†’ ê¸°ì¡´ ì‹œë¦¬ì–¼ ë°ì´í„° í¬ë§· ìœ ì§€
---

í…ŒìŠ¤íŠ¸ ë° ê²€ì¦

- ìƒë³´ í•„í„° í…ŒìŠ¤íŠ¸
  
   STM32ì˜ printf()ë¥¼ í™œìš©í•´ ì‹œë¦¬ì–¼ ëª¨ë‹ˆí„°ì—ì„œ Pitch, Roll, Yawë¥¼ í™•ì¸í•˜ì„¸ìš”.
  
- Yaw ë“œë¦¬í”„íŠ¸ í™•ì¸
  
   MPU6050ë§Œ ì‚¬ìš©í•  ê²½ìš° yaw ê°’ì´ ì‹œê°„ì´ ì§€ë‚˜ë©´ì„œ driftí•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
  
   í•„ìš”í•˜ë©´ **ìžê¸° ì„¼ì„œ(HMC5883L)**ë¥¼ ì¶”ê°€í•´ ë³´ì •í•˜ì„¸ìš”.
---
ì´ì œ STM32ì—ì„œ MPU6050ì˜ pitch, roll, yawë¥¼ ìƒë³´ í•„í„°ë¡œ ê³„ì‚°í•˜ê³ , ì‹œë¦¬ì–¼ë¡œ ì „ì†¡í•˜ëŠ” ì½”ë“œê°€ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤! ðŸš€
ì¶”ê°€ ê°œì„ ì´ í•„ìš”í•˜ë©´ ì•Œë ¤ì£¼ì„¸ìš”! ðŸ˜ƒ

ì´ë²ˆì—ëŠ” ì¹¼ë§Œí•„í„°ë¡œ pitch rollyawë¥¼ ê³„ì‚°í•˜ëŠ” ë°©ë²•ì„ ì•Œë ¤ì£¼ì„¸ìš”

ì¹¼ë§Œ í•„í„°(Kalman Filter)ë¥¼ ì‚¬ìš©í•˜ì—¬ Pitch, Roll, Yawë¥¼ ê³„ì‚°í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•˜ê³ , ì´ë¥¼ STM32 ì½”ë“œì— ì ìš©í•˜ëŠ” ì˜ˆì œë¥¼ ì œê³µí•˜ê² ìŠµë‹ˆë‹¤.
---

ðŸ“Œ 1. ì¹¼ë§Œ í•„í„° ê°œìš”

ì¹¼ë§Œ í•„í„°ëŠ” ì„¼ì„œ ë°ì´í„°ì˜ ë…¸ì´ì¦ˆë¥¼ ì¤„ì´ê³  ë” ì •ë°€í•œ ê°ë„ë¥¼ ì–»ê¸° ìœ„í•´ ì‚¬ìš©ë©ë‹ˆë‹¤.
MPU6050ì˜ ê°€ì†ë„ê³„(Accelerometer)ì™€ ìžì´ë¡œìŠ¤ì½”í”„(Gyroscope) ë°ì´í„°ë¥¼ ì¡°í•©í•˜ì—¬ ê°ë„ë¥¼ ì¶”ì •í•©ë‹ˆë‹¤.

âœ… ì¹¼ë§Œ í•„í„°ì˜ ì£¼ìš” ê¸°ëŠ¥

1. ì˜ˆì¸¡ ë‹¨ê³„ (Prediction)
	- ì´ì „ ìƒíƒœì™€ ìžì´ë¡œìŠ¤ì½”í”„ ë°ì´í„°ë¥¼ ì´ìš©í•˜ì—¬ ë‹¤ìŒ ìƒíƒœë¥¼ ì˜ˆì¸¡í•©ë‹ˆë‹¤.
2. ë³´ì • ë‹¨ê³„ (Correction)
	- ê°€ì†ë„ê³„ë¥¼ ì‚¬ìš©í•˜ì—¬ ì˜ˆì¸¡ëœ ê°ë„ë¥¼ ë³´ì •í•©ë‹ˆë‹¤.
3. ê°€ì¤‘ì¹˜ ì¡°ì ˆ (Kalman Gain)
	- ì„¼ì„œì˜ ì‹ ë¢°ë„ë¥¼ ê³ ë ¤í•˜ì—¬ ìžì´ë¡œìŠ¤ì½”í”„ì™€ ê°€ì†ë„ê³„ ë°ì´í„°ë¥¼ ìµœì ì˜ ë¹„ìœ¨ë¡œ ì¡°í•©í•©ë‹ˆë‹¤.
---

ðŸ“Œ 2. ì¹¼ë§Œ í•„í„° ìˆ˜ì‹

ì¹¼ë§Œ í•„í„°ì˜ ì—…ë°ì´íŠ¸ ê³¼ì •ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

1ï¸âƒ£ ìƒíƒœ ì˜ˆì¸¡

x^=x+Ï‰â‹…dt\hat{x} = x + \omega \cdot dtP=P+QP = P + Q
- xx : í˜„ìž¬ ì¶”ì •ëœ ê°ë„
- Ï‰\omega : ìžì´ë¡œìŠ¤ì½”í”„ ê°ì†ë„ (deg/s)
- dtdt : ì‹œê°„ ê°„ê²©
- PP : ì˜¤ì°¨ ê³µë¶„ì‚° í–‰ë ¬
- QQ : í”„ë¡œì„¸ìŠ¤ ë…¸ì´ì¦ˆ (ìžì´ë¡œìŠ¤ì½”í”„ ë…¸ì´ì¦ˆ)

2ï¸âƒ£ ì¸¡ì • ë³´ì •

K=PP+RK = \frac{P}{P + R}x=x^+K(zâˆ’x^)x = \hat{x} + K (z - \hat{x})P=(1âˆ’K)PP = (1 - K) P
- KK : ì¹¼ë§Œ ì´ë“ (Kalman Gain)
- zz : ê°€ì†ë„ê³„ ê¸°ë°˜ ì¸¡ì •ëœ ê°ë„
- RR : ì¸¡ì • ë…¸ì´ì¦ˆ (ê°€ì†ë„ê³„ ë…¸ì´ì¦ˆ)
---

ðŸ“Œ 3. STM32 ì¹¼ë§Œ í•„í„° ì½”ë“œ

ì¹¼ë§Œ í•„í„°ë¥¼ ì ìš©í•˜ì—¬ Pitch, Roll, Yawë¥¼ ê³„ì‚°í•˜ëŠ” STM32 ì½”ë“œìž…ë‹ˆë‹¤.

ðŸ”¹ ì¹¼ë§Œ í•„í„° êµ¬ì¡°ì²´ ì •ì˜

```
typedef struct {
    float angle;  // ì¶”ì •ëœ ê°ë„
    float bias;   // ìžì´ë¡œìŠ¤ì½”í”„ ë°”ì´ì–´ìŠ¤
    float rate;   // ìžì´ë¡œìŠ¤ì½”í”„ ì¸¡ì •ê°’

    float P[2][2];  // ì˜¤ì°¨ ê³µë¶„ì‚° í–‰ë ¬
    float K[2];     // ì¹¼ë§Œ ì´ë“
    float y;        // ì¸¡ì • ì°¨ì´
    float S;        // ì˜¤ì°¨ ê³µë¶„ì‚°
} KalmanFilter;

```

---

ðŸ”¹ ì¹¼ë§Œ í•„í„° ì´ˆê¸°í™” í•¨ìˆ˜

```
void Kalman_Init(KalmanFilter *kf) {
    kf->angle = 0.0;
    kf->bias = 0.0;
    kf->P[0][0] = 1.0;  kf->P[0][1] = 0.0;
    kf->P[1][0] = 0.0;  kf->P[1][1] = 1.0;
}

```

---

ðŸ”¹ ì¹¼ë§Œ í•„í„° ì—…ë°ì´íŠ¸ í•¨ìˆ˜

```
float Kalman_Update(KalmanFilter *kf, float newAngle, float newRate, float dt) {
    // 1ï¸âƒ£ ì˜ˆì¸¡ ë‹¨ê³„
    kf->rate = newRate - kf->bias;
    kf->angle += dt * kf->rate;

    // ì˜¤ì°¨ ê³µë¶„ì‚° í–‰ë ¬ ì—…ë°ì´íŠ¸
    kf->P[0][0] += dt * (dt * kf->P[1][1] - kf->P[0][1] - kf->P[1][0] + 0.001);
    kf->P[0][1] -= dt * kf->P[1][1];
    kf->P[1][0] -= dt * kf->P[1][1];
    kf->P[1][1] += 0.003;

    // 2ï¸âƒ£ ë³´ì • ë‹¨ê³„
    kf->S = kf->P[0][0] + 0.03;
    kf->K[0] = kf->P[0][0] / kf->S;
    kf->K[1] = kf->P[1][0] / kf->S;

    kf->y = newAngle - kf->angle;
    kf->angle += kf->K[0] * kf->y;
    kf->bias += kf->K[1] * kf->y;

    // ì˜¤ì°¨ ê³µë¶„ì‚° ì—…ë°ì´íŠ¸
    float P00_temp = kf->P[0][0];
    float P01_temp = kf->P[0][1];

    kf->P[0][0] -= kf->K[0] * P00_temp;
    kf->P[0][1] -= kf->K[0] * P01_temp;
    kf->P[1][0] -= kf->K[1] * P00_temp;
    kf->P[1][1] -= kf->K[1] * P01_temp;

    return kf->angle;
}

```

---

ðŸ”¹ ë©”ì¸ ì½”ë“œì— ì ìš©

```
/* Kalman í•„í„° ë³€ìˆ˜ ì„ ì–¸ */
KalmanFilter kalman_pitch, kalman_roll, kalman_yaw;

/* ì´ˆê¸°í™” */
Kalman_Init(&kalman_pitch);
Kalman_Init(&kalman_roll);
Kalman_Init(&kalman_yaw);

void Compute_Orientation_Kalman() {
    // ê°€ì†ë„ê³„ ê¸°ë°˜ pitch, roll ê³„ì‚°
    float acc_pitch = atan2(-ax, sqrt(ay * ay + az * az)) * 57.2958;
    float acc_roll  = atan2(ay, az) * 57.2958;

    // ìžì´ë¡œìŠ¤ì½”í”„ ê°’ì„ deg/s ë‹¨ìœ„ë¡œ ë³€í™˜
    float gx_dps = gx / 131.0;
    float gy_dps = gy / 131.0;
    float gz_dps = gz / 131.0;

    // ì¹¼ë§Œ í•„í„° ì ìš©
    pitch_f = Kalman_Update(&kalman_pitch, acc_pitch, gy_dps, dt);
    roll_f  = Kalman_Update(&kalman_roll, acc_roll, gx_dps, dt);
    yaw_f   = Kalman_Update(&kalman_yaw, yaw_f, gz_dps, dt);

    // float -> int ë³€í™˜
    pitch = (int16_t)(pitch_f * 100);
    roll  = (int16_t)(roll_f * 100);
    yaw   = (int16_t)(yaw_f * 100);
}

```

---

ðŸ”¹ ë°ì´í„° ì „ì†¡ í¬ë§· ìœ ì§€

```
Send_IMU_Data(&ax, &ay, &az, &gx, &gy, &gz, &pitch, &roll, &yaw);

```

---

ðŸ“Œ 4. ìš”ì•½ ë° ì¶”ì²œ

âœ… ìƒë³´ í•„í„° vs ì¹¼ë§Œ í•„í„°
í•„í„°
ìž¥ì 
ë‹¨ì 
ìƒë³´ í•„í„°
ê°„ë‹¨í•˜ê³  ì—°ì‚°ì´ ì ìŒ
Yaw drift ì¡´ìž¬
ì¹¼ë§Œ í•„í„°
ë…¸ì´ì¦ˆ ì œê±° ë° ì •í™•ë„ ì¦ê°€
ì—°ì‚°ëŸ‰ ë§ŽìŒ
ðŸ’¡ ì¶”ì²œ:
1ï¸âƒ£ ì²˜ìŒì—ëŠ” ìƒë³´ í•„í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ í…ŒìŠ¤íŠ¸
2ï¸âƒ£ ë” ì •ë°€í•œ ì¸¡ì •ì´ í•„ìš”í•˜ë©´ ì¹¼ë§Œ í•„í„° ì ìš©
3ï¸âƒ£ Yawì˜ ë“œë¦¬í”„íŠ¸ê°€ ë¬¸ì œë¼ë©´ ìžê¸° ì„¼ì„œ ì¶”ê°€ ê³ ë ¤
---
ì´ì œ STM32ì—ì„œ ì¹¼ë§Œ í•„í„°ë¥¼ ì ìš©í•œ Pitch, Roll, Yaw ê³„ì‚°ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤! ðŸš€
ì¶”ê°€ ì§ˆë¬¸ì´ ìžˆë‹¤ë©´ ì–¸ì œë“ ì§€ ì•Œë ¤ì£¼ì„¸ìš”! ðŸ˜Š

í´ëŸ­ì€ HSIë¥¼ ì‚¬ìš©í–ˆê³ , ìµœì¢…ì ìœ¼ë¡œ APB1 íƒ€ì´ë¨¸ í´ëŸ­ì€ 84MHz ì´ë‹¤. ì•„ëž˜ GPTì˜ íšŒë‹µ ì°¸ê³  

STM32ì—ì„œ ë¡œë´‡ íŽŒì›¨ì–´ë¥¼ ë§Œë“¤ê³  ìžˆì–´ìš”. íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ë¡œ 10ms 50ms 100ms ì¸í„°ëŸ½íŠ¸ë¥¼ ë°œìƒì‹œí‚¤ë ¤ê³  í•˜ëŠ”ë° ì–´ë–¤ íƒ€ì´ë¨¸ë¥¼ ì“°ë©´ ë ê¹Œìš”?

STM32F407ì—ì„œ 10ms, 50ms, 100ms ì£¼ê¸°ì˜ íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ë¥¼ ë°œìƒì‹œí‚¤ë ¤ë©´ TIM2~TIM5 ë˜ëŠ” TIM6, TIM7ê³¼ ê°™ì€ ì¼ë°˜-purpose íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ìž…ë‹ˆë‹¤.

âœ… ì‚¬ìš© ê°€ëŠ¥í•œ íƒ€ì´ë¨¸

STM32F407ì˜ íƒ€ì´ë¨¸ëŠ” í¬ê²Œ ì¼ë°˜-purpose íƒ€ì´ë¨¸ (TIM2~TIM5), ë² ì´ì§ íƒ€ì´ë¨¸ (TIM6, TIM7), ê·¸ë¦¬ê³  **ê³ ì† íƒ€ì´ë¨¸ (TIM1, TIM8)**ë¡œ ë‚˜ë‰©ë‹ˆë‹¤.
ì£¼ê¸°ì ì¸ ì¸í„°ëŸ½íŠ¸ ë°œìƒì„ ìœ„í•´ì„œëŠ” TIM2~TIM5 ë˜ëŠ” TIM6, TIM7ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì ì ˆí•©ë‹ˆë‹¤.

1ï¸âƒ£ TIM2~TIM5 (32ë¹„íŠ¸ íƒ€ì´ë¨¸, ì¼ë°˜-purpose)

- 32ë¹„íŠ¸ ì¹´ìš´í„°ì´ë¯€ë¡œ ê¸´ ì£¼ê¸°ë„ ì„¤ì • ê°€ëŠ¥
- ì£¼ íƒ€ì´ë¨¸ í´ëŸ­: 84MHz (APB1 Timer Clock)
- PSC (í”„ë¦¬ìŠ¤ì¼€ì¼ëŸ¬)ì™€ ARR (ìžë™ ë¦¬ë¡œë“œ ë ˆì§€ìŠ¤í„°)ë¥¼ ì¡°ì •í•˜ì—¬ ì›í•˜ëŠ” ì£¼ê¸°ë¡œ ì¸í„°ëŸ½íŠ¸ ìƒì„± ê°€ëŠ¥

2ï¸âƒ£ TIM6, TIM7 (16ë¹„íŠ¸ íƒ€ì´ë¨¸, ë² ì´ì§ íƒ€ì´ë¨¸)

- PWM ì—†ì´ ì¸í„°ëŸ½íŠ¸ ì „ìš©ìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥
- ì£¼ íƒ€ì´ë¨¸ í´ëŸ­: 84MHz (APB1 Timer Clock)

âœ… 10ms, 50ms, 100ms íƒ€ì´ë¨¸ ì„¤ì • ë°©ë²• (TIM2~TIM5 ì‚¬ìš©)

ðŸ’¡ 84MHz íƒ€ì´ë¨¸ í´ëŸ­ ê¸°ì¤€ìœ¼ë¡œ 10ms ì£¼ê¸°ì˜ ì¸í„°ëŸ½íŠ¸ ë°œìƒì„ ìœ„í•œ ì„¤ì • ì˜ˆì‹œ
```
// TIM2ë¥¼ ì‚¬ìš©í•œ 10ms, 50ms, 100ms íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ ì„¤ì • ì˜ˆì‹œ
void Timer_Config(void) {
    __HAL_RCC_TIM2_CLK_ENABLE(); // TIM2 í´ëŸ­ í™œì„±í™”

    TIM_HandleTypeDef htim2;
    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 8400 - 1;  // 84MHz / 8400 = 10kHz (0.1ms)
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim2.Init.Period = 100 - 1;  // 10kHz -> 100 (10ms)
    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    HAL_TIM_Base_Init(&htim2);

    HAL_TIM_Base_Start_IT(&htim2); // ì¸í„°ëŸ½íŠ¸ í™œì„±í™”

    // NVIC ì¸í„°ëŸ½íŠ¸ ì„¤ì •
    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
}

// ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ (10msë§ˆë‹¤ í˜¸ì¶œë¨)
void TIM2_IRQHandler(void) {
    if (__HAL_TIM_GET_FLAG(&htim2, TIM_FLAG_UPDATE) != RESET) {
        __HAL_TIM_CLEAR_IT(&htim2, TIM_IT_UPDATE);

        // 10ms íƒ€ì´ë¨¸ ì´ë²¤íŠ¸ ì²˜ë¦¬
    }
}

```

âœ… 50ms, 100msë„ ì‚¬ìš©í•˜ë ¤ë©´?

- ìœ„ì˜ TIM2ë¥¼ ì‚¬ìš©í•˜ì—¬ ê¸°ë³¸ì ìœ¼ë¡œ 10msë§ˆë‹¤ ì¸í„°ëŸ½íŠ¸ë¥¼ ë°œìƒì‹œí‚¤ê³ ,
- 50ms(5ë²ˆ í˜¸ì¶œë§ˆë‹¤ ì‹¤í–‰), 100ms(10ë²ˆ í˜¸ì¶œë§ˆë‹¤ ì‹¤í–‰) ì²˜ë¦¬ë¥¼ ì¶”ê°€í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
```
static uint8_t tick_50ms = 0;
static uint8_t tick_100ms = 0;

void TIM2_IRQHandler(void) {
    if (__HAL_TIM_GET_FLAG(&htim2, TIM_FLAG_UPDATE) != RESET) {
        __HAL_TIM_CLEAR_IT(&htim2, TIM_IT_UPDATE);

        // 10ms íƒ€ì´ë¨¸ ì´ë²¤íŠ¸
        tick_50ms++;
        tick_100ms++;

        if (tick_50ms >= 5) {  // 50msë§ˆë‹¤ ì‹¤í–‰
            tick_50ms = 0;
            // 50ms ì´ë²¤íŠ¸ ì‹¤í–‰
        }

        if (tick_100ms >= 10) {  // 100msë§ˆë‹¤ ì‹¤í–‰
            tick_100ms = 0;
            // 100ms ì´ë²¤íŠ¸ ì‹¤í–‰
        }
    }
}

```

âœ… TIM6 ë˜ëŠ” TIM7ì„ ì‚¬ìš©í•˜ë ¤ë©´?

- ê¸°ë³¸ íƒ€ì´ë¨¸ì¸ TIM6 ë˜ëŠ” TIM7ì„ ì‚¬ìš©í•  ìˆ˜ë„ ìžˆìŠµë‹ˆë‹¤.
- ê°™ì€ ë°©ì‹ìœ¼ë¡œ í”„ë¦¬ìŠ¤ì¼€ì¼ëŸ¬ì™€ ARRì„ ì¡°ì •í•˜ì—¬ 10msë§ˆë‹¤ ì¸í„°ëŸ½íŠ¸ë¥¼ ë°œìƒì‹œí‚¤ê³ , ì¹´ìš´í„°ë¥¼ ì´ìš©í•´ 50ms, 100ms ì²˜ë¦¬ë¥¼ í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
---

ðŸš€ ê²°ë¡ 

1. TIM2~TIM5 (32ë¹„íŠ¸ íƒ€ì´ë¨¸) ë˜ëŠ” TIM6, TIM7 (16ë¹„íŠ¸ ë² ì´ì§ íƒ€ì´ë¨¸) ì¤‘ í•˜ë‚˜ë¥¼ ì‚¬ìš©.
2. 84MHz í´ëŸ­ ê¸°ì¤€ìœ¼ë¡œ 10msë§ˆë‹¤ ì¸í„°ëŸ½íŠ¸ ë°œìƒ, ë‚´ë¶€ ì¹´ìš´í„°ë¡œ 50ms, 100ms ì²˜ë¦¬ë¥¼ ì¶”ê°€.
3. TIM2ë¥¼ ì¶”ì²œ (ë‹¤ë¥¸ íƒ€ì´ë¨¸ëŠ” PWM ë“±ê³¼ ì¶©ëŒí•  ê°€ëŠ¥ì„± ìžˆìŒ).
ì´ ë°©ë²•ìœ¼ë¡œ êµ¬í˜„í•˜ë©´ 10ms, 50ms, 100ms ê°„ê²©ìœ¼ë¡œ ì•ˆì •ì ì¸ íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ë¥¼ ë§Œë“¤ ìˆ˜ ìžˆìŠµë‹ˆë‹¤! ðŸš€

í´ëŸ­ì„ ì…‹íŒ…í•˜ê¸° 
íƒ€ì´ë¨¸í´ëŸ­ 84MHzëŠ” ì–´ë–»ê²Œ ì„¤ì •í•˜ë‚˜ìš”? HSIë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

STM32F407ì—ì„œ **HSI (ë‚´ë¶€ 16MHz ì˜¤ì‹¤ë ˆì´í„°)**ë¥¼ ì‚¬ìš©í•  ë•Œ, ì‹œìŠ¤í…œ í´ëŸ­ì„ 84MHzë¡œ ì„¤ì •í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•˜ê² ìŠµë‹ˆë‹¤.

âœ… 1. HSI ì‚¬ìš© ì‹œ ê¸°ë³¸ í´ëŸ­ ì„¤ì • ê°œìš”

- STM32F407ì˜ HSI í´ëŸ­ì€ 16MHzìž…ë‹ˆë‹¤.
- PLLì„ ì‚¬ìš©í•˜ì—¬ ì‹œìŠ¤í…œ í´ëŸ­ì„ 84MHzë¡œ ì„¤ì •í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
- APB1 ë²„ìŠ¤ (TIM2~TIM5, TIM6, TIM7 íƒ€ì´ë¨¸ê°€ ì†í•¨)ì˜ í´ëŸ­ì€ 42MHzì´ë©°, ì´ ë²„ìŠ¤ì˜ íƒ€ì´ë¨¸ëŠ” 2ë°° í´ëŸ­(=84MHz)ë¡œ ë™ìž‘í•©ë‹ˆë‹¤.
---

âœ… 2. HSI ê¸°ë°˜ 84MHz ì„¤ì • ë°©ë²• (PLL ì‚¬ìš©)

ì‹œìŠ¤í…œ í´ëŸ­ì„ 84MHzë¡œ ì„¤ì •í•˜ë ¤ë©´ ë‹¤ìŒê³¼ ê°™ì´ PLL ì„¤ì •ì„ í•©ë‹ˆë‹¤.
ì„¤ì •ê°’
ì„¤ëª…
HSI (16MHz)
ê¸°ë³¸ ë‚´ë¶€ ì˜¤ì‹¤ë ˆì´í„°
PLLM = 16
PLL ìž…ë ¥ í´ëŸ­ì„ 1MHzë¡œ ë§Œë“¦ (16MHz / 16 = 1MHz)
PLLN = 168
PLL ì£¼íŒŒìˆ˜ë¥¼ 168MHzë¡œ ì¦í­ (1MHz Ã— 168 = 168MHz)
PLLP = 2
ì‹œìŠ¤í…œ í´ëŸ­ì„ 84MHzë¡œ ì„¤ì • (168MHz / 2 = 84MHz)
PLLQ = 7
USB í´ëŸ­ ì„¤ì • (ì‚¬ìš©í•˜ì§€ ì•Šì•„ë„ ë¨)

---

âœ… 3. ì½”ë“œ ì˜ˆì œ (HSI â†’ 84MHz ì‹œìŠ¤í…œ í´ëŸ­ ì„¤ì •)

ì•„ëž˜ëŠ” HSIë¥¼ ì‚¬ìš©í•˜ì—¬ PLLì„ ì„¤ì •í•˜ê³ , ì‹œìŠ¤í…œ í´ëŸ­ì„ 84MHzë¡œ ì„¤ì •í•˜ëŠ” ì½”ë“œìž…ë‹ˆë‹¤.
```
void SystemClock_Config(void) {
    // ì „ì› í´ëŸ­ í™œì„±í™”
    __HAL_RCC_PWR_CLK_ENABLE();

    // ì „ì•• ì¡°ì •: ì„±ëŠ¥ ëª¨ë“œë¥¼ ìœ„í•´ ì¡°ì • (3.3Vì—ì„œ ìµœì  ì„±ëŠ¥)
    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

    // HSIë¥¼ ì‚¬ìš©í•˜ë„ë¡ ì„¤ì •
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
    RCC_OscInitStruct.HSIState = RCC_HSI_ON;  // HSI í™œì„±í™”
    RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
    RCC_OscInitStruct.PLL.PLLM = 16;
    RCC_OscInitStruct.PLL.PLLN = 168;
    RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;  // SYSCLK = 168MHz / 2 = 84MHz
    RCC_OscInitStruct.PLL.PLLQ = 7;  // USB, SDIO, RNG í´ëŸ­

    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
        // ì˜¤ë¥˜ ì²˜ë¦¬
        while (1);
    }

    // ë²„ìŠ¤ í´ëŸ­ ì„¤ì •
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK |
                                  RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;  // 84MHz
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;   // 42MHz (APB1)
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;   // 84MHz (APB2)

    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) {
        // ì˜¤ë¥˜ ì²˜ë¦¬
        while (1);
    }

    // Systick ì„¤ì • (1ms ë‹¨ìœ„ íƒ€ì´ë¨¸)
    HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / 1000);
    HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
}

```

---

âœ… 4. íƒ€ì´ë¨¸ í´ëŸ­ í™•ì¸

ì‹œìŠ¤í…œ í´ëŸ­ì´ ì •ìƒì ìœ¼ë¡œ ì„¤ì •ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ë°©ë²•ìž…ë‹ˆë‹¤.
```
// í˜„ìž¬ í´ëŸ­ ì£¼íŒŒìˆ˜ë¥¼ í™•ì¸í•˜ëŠ” ì½”ë“œ
void Check_Clock_Frequencies() {
    uint32_t sysclk = HAL_RCC_GetSysClockFreq();   // SYSCLK (84MHz ì˜ˆìƒ)
    uint32_t hclk = HAL_RCC_GetHCLKFreq();         // AHB í´ëŸ­ (84MHz)
    uint32_t pclk1 = HAL_RCC_GetPCLK1Freq();       // APB1 í´ëŸ­ (42MHz)
    uint32_t pclk2 = HAL_RCC_GetPCLK2Freq();       // APB2 í´ëŸ­ (84MHz)

    printf("SYSCLK: %lu Hz\n", sysclk);
    printf("HCLK: %lu Hz\n", hclk);
    printf("PCLK1: %lu Hz\n", pclk1);
    printf("PCLK2: %lu Hz\n", pclk2);
}

```

---

âœ… 5. íƒ€ì´ë¨¸ í´ëŸ­ (TIM2~TIM5, TIM6, TIM7)

- APB1 í´ëŸ­ = 42MHz
- APB1 íƒ€ì´ë¨¸ (TIM2~TIM5, TIM6, TIM7) í´ëŸ­ = 84MHz (APB1 íƒ€ì´ë¨¸ëŠ” 2ë°° ì†ë„)
ì´ì œ íƒ€ì´ë¨¸ë¥¼ ì„¤ì •í•˜ë©´ 84MHz íƒ€ì´ë¨¸ í´ëŸ­ì„ ì‚¬ìš©í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
ì˜ˆì œ:
```
htim2.Init.Prescaler = 8400 - 1;  // 84MHz / 8400 = 10kHz (0.1ms)
htim2.Init.Period = 100 - 1;      // 100 * 0.1ms = 10ms ì£¼ê¸° ì¸í„°ëŸ½íŠ¸

```

---

ðŸš€ ê²°ë¡ 

- HSI (16MHz) â†’ PLL ì„¤ì • â†’ ì‹œìŠ¤í…œ í´ëŸ­ 84MHzë¡œ ì„¤ì • ê°€ëŠ¥
- APB1 (TIM2~TIM5, TIM6, TIM7) í´ëŸ­ = 42MHz, íƒ€ì´ë¨¸ í´ëŸ­ = 84MHz
- íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ëŠ” ìœ„ ì„¤ì •ì„ ê¸°ë°˜ìœ¼ë¡œ ì›í•˜ëŠ” ì£¼ê¸°ë¡œ ì„¤ì • ê°€ëŠ¥.
ì´ì œ ì›í•˜ëŠ” 10ms, 50ms, 100ms íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤! ðŸŽ¯


STM32ì—ì„œ 10ms 50ms 100ms ì¸í„°ëŸ½íŠ¸ë¥¼ ë°œìƒí•  ë–¼, ê°ê°ì˜ íƒ€ì´ë¨¸ë¥¼ ì“°ëŠ” ê²ƒì´ ë‚«ë‚˜ìš”? ì•„ë‹ˆë©´ í•œê°œì˜ íƒ€ì´ë¨¸ì— ë³€ìˆ˜ë¥¼ ë‘ì–´ì„œ ë¶„ê¸°í•˜ëŠ” ê²ƒì´ ë‚«ë‚˜ìš”?

STM32ì—ì„œ 10ms, 50ms, 100ms ì£¼ê¸°ë¡œ ì¸í„°ëŸ½íŠ¸ë¥¼ ë°œìƒì‹œí‚¤ëŠ” ë°©ë²•ìœ¼ë¡œ ë‘ ê°€ì§€ ë°©ë²•ì„ ë¹„êµí•´ ë³´ê² ìŠµë‹ˆë‹¤.
1. ê°ê°ì˜ íƒ€ì´ë¨¸(TIM) ì‚¬ìš©
2. í•˜ë‚˜ì˜ íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•˜ê³  ë³€ìˆ˜ë¡œ ë¶„ê¸°

âœ… 1. ê°ê°ì˜ íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•

STM32ì˜ ì—¬ëŸ¬ ê°œì˜ TIMì„ ì‚¬ìš©í•˜ì—¬ ê°ê°ì˜ ì£¼ê¸°ë¥¼ ì„¤ì •í•˜ëŠ” ë°©ë²•ìž…ë‹ˆë‹¤.

ìž¥ì 

- ë…ë¦½ì ì¸ íƒ€ì´ë¨¸ ë™ìž‘ â†’ ê°„ì„­ì´ ì—†ìŒ.
- ì •í™•í•œ ì£¼ê¸° ë³´ìž¥ â†’ ë‹¤ë¥¸ ì£¼ê¸°ì˜ ì˜í–¥ì„ ë°›ì§€ ì•ŠìŒ.
- ë” ì§ê´€ì ì¸ ì½”ë“œ â†’ íŠ¹ì • íƒ€ì´ë¨¸ê°€ íŠ¹ì • ì£¼ê¸°ë¥¼ ë‹´ë‹¹.

ë‹¨ì 

- TIM ë¦¬ì†ŒìŠ¤ ì‚¬ìš© ì¦ê°€ â†’ TIMì„ ë§Žì´ ì‚¬ìš©í•˜ë©´ ë‹¤ë¥¸ ê¸°ëŠ¥ì„ ì¶”ê°€í•˜ê¸° ì–´ë ¤ì›€.
- ì „ë ¥ ì†Œë¹„ ì¦ê°€ (ì €ì „ë ¥ ì‹œìŠ¤í…œì—ì„œëŠ” ë¬¸ì œê°€ ë  ìˆ˜ë„ ìžˆìŒ).

ì˜ˆì œ ì½”ë“œ

```
void MX_TIM2_Init(void) {  // 10ms íƒ€ì´ë¨¸
    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 7999;  // 8MHz / (7999 + 1) = 1kHz
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim2.Init.Period = 9;  // 10ms (1kHz * 10ms = 10)
    HAL_TIM_Base_Init(&htim2);
    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
}

void MX_TIM3_Init(void) {  // 50ms íƒ€ì´ë¨¸
    htim3.Instance = TIM3;
    htim3.Init.Prescaler = 7999;
    htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim3.Init.Period = 49;  // 50ms
    HAL_TIM_Base_Init(&htim3);
    HAL_NVIC_SetPriority(TIM3_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(TIM3_IRQn);
}

void MX_TIM4_Init(void) {  // 100ms íƒ€ì´ë¨¸
    htim4.Instance = TIM4;
    htim4.Init.Prescaler = 7999;
    htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim4.Init.Period = 99;  // 100ms
    HAL_TIM_Base_Init(&htim4);
    HAL_NVIC_SetPriority(TIM4_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(TIM4_IRQn);
}

void TIM2_IRQHandler(void) {
    HAL_TIM_IRQHandler(&htim2);
}

void TIM3_IRQHandler(void) {
    HAL_TIM_IRQHandler(&htim3);
}

void TIM4_IRQHandler(void) {
    HAL_TIM_IRQHandler(&htim4);
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
    if (htim->Instance == TIM2) {
        // 10ms ìž‘ì—… ìˆ˜í–‰
    } else if (htim->Instance == TIM3) {
        // 50ms ìž‘ì—… ìˆ˜í–‰
    } else if (htim->Instance == TIM4) {
        // 100ms ìž‘ì—… ìˆ˜í–‰
    }
}

```

---

âœ… 2. í•˜ë‚˜ì˜ íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•˜ê³  ë³€ìˆ˜ë¡œ ë¶„ê¸°í•˜ëŠ” ë°©ë²•

í•œ ê°œì˜ íƒ€ì´ë¨¸ë¥¼ ì„¤ì •í•˜ì—¬ ìµœì†Œ ì£¼ê¸°(ì˜ˆ: 10ms)ë¡œ ì¸í„°ëŸ½íŠ¸ë¥¼ ë°œìƒì‹œí‚¤ê³ , ë³€ìˆ˜ ì¹´ìš´íŠ¸ë¥¼ í†µí•´ 50ms, 100ms ìž‘ì—…ì„ ë¶„ê¸°í•˜ëŠ” ë°©ë²•ìž…ë‹ˆë‹¤.

ìž¥ì 

- íƒ€ì´ë¨¸ ìžì›ì„ ì ê²Œ ì‚¬ìš© â†’ TIMì„ í•˜ë‚˜ë§Œ ì‚¬ìš©.
- ì¼ì •í•œ ì£¼ê¸°ë¡œ ì—¬ëŸ¬ ì£¼ê¸° ê´€ë¦¬ ê°€ëŠ¥.
- ì½”ë“œê°€ ë‹¨ìˆœí•´ì§ â†’ ì—¬ëŸ¬ ê°œì˜ íƒ€ì´ë¨¸ë¥¼ ì„¤ì •í•  í•„ìš” ì—†ìŒ.

ë‹¨ì 

- ì¸í„°ëŸ½íŠ¸ì—ì„œ ì¶”ê°€ ì—°ì‚° í•„ìš” (ë³€ìˆ˜ë¥¼ ì¦ê°€ì‹œí‚¤ê³  ì¡°ê±´ë¬¸ í™•ì¸).
- ì¸í„°ëŸ½íŠ¸ì˜ ì‹¤í–‰ ì‹œê°„ì´ ê¸¸ì–´ì§ˆ ìˆ˜ ìžˆìŒ (ìž‘ì—…ëŸ‰ì´ ë§Žì•„ì§€ë©´ ë¶€ë‹´ë  ìˆ˜ ìžˆìŒ).
- íƒ€ì´ë¨¸ì˜ ê¸°ë³¸ ì£¼ê¸°ê°€ ë„ˆë¬´ í¬ë©´ ì •ë°€ë„ ì €í•˜ (10ms ì£¼ê¸°ë¡œ 1ms ë‹¨ìœ„ë¥¼ ë‹¤ë£¨ë ¤ë©´ ì–´ë µë‹¤).

ì˜ˆì œ ì½”ë“œ

```
volatile uint32_t timer_counter = 0;

void MX_TIM2_Init(void) {  // 10ms ë‹¨ìœ„ íƒ€ì´ë¨¸
    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 7999;  // 8MHz / (7999 + 1) = 1kHz
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim2.Init.Period = 9;  // 10ms (1kHz * 10ms = 10)
    HAL_TIM_Base_Init(&htim2);
    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
}

void TIM2_IRQHandler(void) {
    HAL_TIM_IRQHandler(&htim2);
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
    if (htim->Instance == TIM2) {
        timer_counter++;

        // 10msë§ˆë‹¤ ì‹¤í–‰
        Do10msTask();

        // 50msë§ˆë‹¤ ì‹¤í–‰
        if (timer_counter % 5 == 0) {
            Do50msTask();
        }

        // 100msë§ˆë‹¤ ì‹¤í–‰
        if (timer_counter % 10 == 0) {
            Do100msTask();
        }
        
        if (timer_counter >= 1000) {  // ì˜¤ë²„í”Œë¡œìš° ë°©ì§€ (1000 * 10ms = 10s)
            timer_counter = 0;
        }
    }
}

void Do10msTask(void) {
    HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
}

void Do50msTask(void) {
    // 50ms ì£¼ê¸° ìž‘ì—…
}

void Do100msTask(void) {
    // 100ms ì£¼ê¸° ìž‘ì—…
}

```

---

âœ… ì–´ë–¤ ë°©ë²•ì´ ë” ì¢‹ì„ê¹Œ?


âš¡ ê° íƒ€ì´ë¨¸ë¥¼ ë”°ë¡œ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ì€ ê²½ìš°

âœ” ì •í™•í•œ ì£¼ê¸°ê°€ í•„ìš”í•  ë•Œ (ì˜ˆ: PWM ì‹ í˜¸ ìƒì„±, ê³ ì •ëœ ìƒ˜í”Œë§ ì£¼ê¸°)
âœ” ì—¬ëŸ¬ ê°œì˜ íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìžˆì„ ë•Œ (STM32 íƒ€ì´ë¨¸ê°€ ì¶©ë¶„í•  ë•Œ)
âœ” ì¸í„°ëŸ½íŠ¸ ë¶€í•˜ë¥¼ ìµœì†Œí™”í•˜ê³  ì‹¶ì„ ë•Œ

âš¡ í•œ ê°œì˜ íƒ€ì´ë¨¸ë¡œ ë¶„ê¸°í•˜ëŠ” ê²ƒì´ ì¢‹ì€ ê²½ìš°

âœ” íƒ€ì´ë¨¸ ë¦¬ì†ŒìŠ¤ë¥¼ ì•„ë¼ê³  ì‹¶ì„ ë•Œ (STM32ì—ì„œ TIMì´ ë¶€ì¡±í•  ë•Œ)
âœ” ë‹¨ìˆœí•œ ì½”ë“œ ìœ ì§€ê°€ í•„ìš”í•  ë•Œ
âœ” ë‚®ì€ ì£¼íŒŒìˆ˜(10ms ì´ìƒ)ì—ì„œ ë™ìž‘í•  ë•Œ (ë³€ìˆ˜ ê³„ì‚° ë¶€í•˜ê°€ í¬ì§€ ì•ŠìŒ)
---

ê²°ë¡ 

1. ê°ê°ì˜ íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì€ ë³´ë‹¤ ì •í™•í•œ ì£¼ê¸°ë¥¼ ë³´ìž¥í•˜ì§€ë§Œ, TIM ìžì›ì„ ë§Žì´ ì‚¬ìš©í•©ë‹ˆë‹¤.
2. í•œ ê°œì˜ íƒ€ì´ë¨¸ì—ì„œ ë³€ìˆ˜ë¥¼ í†µí•´ ë¶„ê¸°í•˜ëŠ” ë°©ë²•ì€ TIM ìžì›ì„ ì•„ë‚„ ìˆ˜ ìžˆì§€ë§Œ, ë³€ìˆ˜ë¥¼ í™•ì¸í•˜ëŠ” ì—°ì‚° ë¶€í•˜ê°€ ì•½ê°„ ë°œìƒí•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
ë§Œì•½ íƒ€ì´ë¨¸ ë¦¬ì†ŒìŠ¤ê°€ ì¶©ë¶„í•˜ë‹¤ë©´ ê°ê°ì˜ íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì •í™•ë„ê°€ ë” ë†’ê³  ê°„ì„­ì„ ì¤„ì¼ ìˆ˜ ìžˆì–´ ìœ ë¦¬í•©ë‹ˆë‹¤.
ê·¸ëŸ¬ë‚˜ íƒ€ì´ë¨¸ë¥¼ ë§Žì´ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ê²½ìš°, í•œ ê°œì˜ íƒ€ì´ë¨¸ë¡œ ë¶„ê¸°í•˜ëŠ” ê²ƒì´ íš¨ìœ¨ì ì¸ í•´ê²°ì±…ì´ ë  ìˆ˜ ìžˆìŠµë‹ˆë‹¤. ðŸš€

I2C í†µì‹ ë¬¸ì œ
ì„  ë¬¼ì•ˆì´ ì›ì¸ ì¸ ë“¯ .... í•˜ì—¬ê°„ HAL_OK ì²´í¬í•´ì„œ í•˜ë“œì›¨ì–´ ë¬¸ì œ ìƒê¸´ ê²ƒì€ ì°¾ì„ ìˆ˜ ìžˆì—ˆë‹¤. 

íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•˜ì—¬ MPU6050 IMU ì„¼ì„œë¥¼ ì£¼ê¸°ì ìœ¼ë¡œ ì½ì„ ë•Œ, ê°’ì´ ê³ ì •ë˜ê±°ë‚˜ ì´ìƒí•œ ê°’ì´ ì¶œë ¥ë˜ëŠ” ë¬¸ì œëŠ” ì—¬ëŸ¬ ê°€ì§€ ì›ì¸ìœ¼ë¡œ ì¸í•´ ë°œìƒí•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤. ì£¼ìš” ì›ì¸ì„ ë¶„ì„í•˜ê³  í•´ê²°ì±…ì„ ì œì‹œí•˜ê² ìŠµë‹ˆë‹¤.
---

1. I2C í†µì‹  ë¬¸ì œ


ì›ì¸

- I2C í†µì‹ ì´ ì œëŒ€ë¡œ ì´ë£¨ì–´ì§€ì§€ ì•Šìœ¼ë©´, MPU6050ì—ì„œ ì´ì „ ë°ì´í„°ë¥¼ ê³„ì† ë°˜í™˜í•˜ê±°ë‚˜ 0 ê°’ì„ ë³´ë‚¼ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
- MPU6050ì˜ ì „ì›ì´ ì¶©ë¶„í•˜ì§€ ì•Šê±°ë‚˜, I2C ë¼ì¸ì—ì„œ í’€ì—… ì €í•­ì´ ì—†ìœ¼ë©´ ì •ìƒì ì¸ ë°ì´í„° ì „ì†¡ì´ ì´ë£¨ì–´ì§€ì§€ ì•Šì„ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.

í•´ê²°ì±…

- í’€ì—… ì €í•­ í™•ì¸: I2C SDA/SCL ë¼ì¸ì— 4.7kÎ©~10kÎ© í’€ì—… ì €í•­ì´ ì—°ê²°ë˜ì–´ ìžˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.
- ì „ì•• í™•ì¸: MPU6050ì´ 3.3V ë˜ëŠ” 5Vì—ì„œ ì •ìƒ ë™ìž‘í•˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.
- I2C ìƒíƒœ í™•ì¸: HAL ìƒíƒœ ê°’ì„ í™•ì¸í•˜ì—¬ HAL_I2C_Master_Transmit() ë˜ëŠ” HAL_I2C_Master_Receive()ê°€ HAL_OKë¥¼ ë°˜í™˜í•˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.
  
- WHO_AM_I í™•ì¸: Read_MPU6050_ID() í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ì—¬ ì œëŒ€ë¡œ 0x68 ë˜ëŠ” 0x69 ê°’ì„ ë°˜í™˜í•˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.
---

2. íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ì—ì„œì˜ IMU ë°ì´í„° ì½ê¸° ë¬¸ì œ


ì›ì¸

- íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ëŠ” ì£¼ê¸°ì ìœ¼ë¡œ ë°œìƒí•˜ì§€ë§Œ, I2C í†µì‹ ì€ ë¹„êµì  ëŠë¦° ìž‘ì—…ì´ë¯€ë¡œ ì¸í„°ëŸ½íŠ¸ì—ì„œ ì‹¤í–‰í•˜ë©´ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
- I2C í†µì‹ ì´ ì§„í–‰ ì¤‘ì¸ë° ë‹¤ì‹œ ì¸í„°ëŸ½íŠ¸ê°€ ë°œìƒí•˜ë©´ I2C ìƒíƒœê°€ ê¹¨ì§ˆ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
- f_imu_read = 1; í”Œëž˜ê·¸ë¥¼ ì„¤ì •í–ˆì§€ë§Œ, ë©”ì¸ ë£¨í”„ì—ì„œ ì²˜ë¦¬í•˜ê¸° ì „ì— ê°’ì´ ë®ì–´ì”Œì›Œì§ˆ ê°€ëŠ¥ì„±ì´ ìžˆìŠµë‹ˆë‹¤.

í•´ê²°ì±…

- ì¸í„°ëŸ½íŠ¸ì—ì„œ ì§ì ‘ I2C ì½ì§€ ì•Šê¸°
  í˜„ìž¬ ì½”ë“œëŠ” HAL_TIM_PeriodElapsedCallback()ì—ì„œ f_imu_read = 1;ì„ ì„¤ì •í•œ í›„ ë©”ì¸ ë£¨í”„ì—ì„œ I2C ì½ê¸°ë¥¼ ìˆ˜í–‰í•˜ëŠ” ë°©ì‹ìž…ë‹ˆë‹¤.
  ê·¸ëŸ¬ë‚˜, HAL_I2C_Master_Transmit() ë˜ëŠ” HAL_I2C_Master_Receive()ë¥¼ ì¸í„°ëŸ½íŠ¸ì—ì„œ ì§ì ‘ í˜¸ì¶œí•˜ëŠ” ê²ƒì€ ë§¤ìš° ìœ„í—˜í•©ë‹ˆë‹¤.
  ì˜¬ë°”ë¥¸ ë°©ë²•:
  ê·¸ë¦¬ê³  ë©”ì¸ ë£¨í”„ì—ì„œ ì²˜ë¦¬í•  ë•Œ:
---

3. I2C í†µì‹  ì†ë„ ë¬¸ì œ


ì›ì¸

- I2C ì†ë„ê°€ ë„ˆë¬´ ë¹ ë¥´ë©´ MPU6050ì´ ë°ì´í„°ë¥¼ ì œëŒ€ë¡œ ì œê³µí•˜ì§€ ëª»í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
- í˜„ìž¬ ClockSpeed = 100000 (100kHz)ë¡œ ì„¤ì •ë˜ì–´ ìžˆì§€ë§Œ, ì¼ë¶€ ì„¼ì„œì—ì„œëŠ” ë” ë‚®ì€ ì†ë„ë¥¼ ìš”êµ¬í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.

í•´ê²°ì±…

- ì†ë„ë¥¼ ë‚®ì¶°ì„œ í…ŒìŠ¤íŠ¸í•´ë³´ì„¸ìš”: 
  ë§Œì•½ ì†ë„ë¥¼ 50kHzë¡œ ë‚®ì¶˜ í›„ ì •ìƒ ìž‘ë™í•˜ë©´, 100kHzì—ì„œ ë¬¸ì œê°€ ë°œìƒí–ˆì„ ê°€ëŠ¥ì„±ì´ í½ë‹ˆë‹¤.
---

4. MPU6050ì˜ ì´ˆê¸°í™” ë¬¸ì œ


ì›ì¸

- MPU6050_Init()ì—ì„œ PWR_MGMT_1ì„ 0x00ìœ¼ë¡œ ì„¤ì •í•˜ëŠ” ê²ƒ ì™¸ì—ë„, ê¸°ë³¸ì ìœ¼ë¡œ MPU6050ì´ ë™ìž‘í•˜ê¸° ìœ„í•´ ëª‡ ê°€ì§€ ì„¤ì •ì´ í•„ìš”í•©ë‹ˆë‹¤.

í•´ê²°ì±…

- MPU6050_Init()ì„ ì•„ëž˜ì²˜ëŸ¼ ìˆ˜ì •í•´ë³´ì„¸ìš”:
  
	- ì¤‘ìš”í•œ ì ì€ ì„¤ì • ê°„ì˜ HAL_Delay(10);ì„ ë°˜ë“œì‹œ ë„£ì–´ì•¼ í•œë‹¤ëŠ” ê²ƒìž…ë‹ˆë‹¤.
	- CONFIG ë ˆì§€ìŠ¤í„°ë¥¼ ì„¤ì •í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.
---

5. MPU6050ì´ ìŠ¬ë¦½ ëª¨ë“œì—ì„œ ë²—ì–´ë‚˜ì§€ ì•ŠìŒ


ì›ì¸

- PWR_MGMT_1 = 0x00ì„ ì„¤ì •í•˜ëŠ” ê²ƒì´ MPU6050ì„ ìŠ¬ë¦½ ëª¨ë“œì—ì„œ ê¹¨ìš°ëŠ” ë™ìž‘ì´ì§€ë§Œ, ì¼ë¶€ ë³´ë“œì—ì„œëŠ” ì¶”ê°€ ì„¤ì •ì´ í•„ìš”í•©ë‹ˆë‹¤.

í•´ê²°ì±…

- MPU6050_Init()ì—ì„œ ë‹¤ìŒì„ ì¶”ê°€í•˜ì„¸ìš”:
  
	- 0x00ì´ ì•„ë‹ˆë¼ 0x01ë¡œ ì„¤ì •í•˜ë©´ ë” ì•ˆì •ì ì¸ ë™ìž‘ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.
---

6. IMU ë°ì´í„°ê°€ ì œëŒ€ë¡œ ë³€í•˜ëŠ”ì§€ í™•ì¸í•˜ëŠ” ë°©ë²•


í•´ê²°ì±…

- UARTë¥¼ í†µí•´ ë°ì´í„°ë¥¼ ì¶œë ¥í•´ë³´ì„¸ìš”: 
- ë°ì´í„°ë¥¼ ì¶œë ¥í•˜ë©´ì„œ IMUë¥¼ ì›€ì§ì´ë©´ ê°’ì´ ë³€í•˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.
---

ê²°ë¡ 

âœ… í™•ì¸í•´ì•¼ í•  ì‚¬í•­
1. I2C í†µì‹  ë¬¸ì œ í•´ê²° (í’€ì—… ì €í•­, ì „ì› í™•ì¸, WHO_AM_I ì²´í¬)
2. íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ì—ì„œ I2C ì§ì ‘ í˜¸ì¶œí•˜ì§€ ì•Šê¸°
3. I2C ì†ë„ë¥¼ 50kHzë¡œ ë‚®ì¶° í…ŒìŠ¤íŠ¸
4. MPU6050 ì´ˆê¸°í™” ê³¼ì • ê°œì„ 
5. MPU6050 ìŠ¬ë¦½ ëª¨ë“œ í•´ì œ ì„¤ì • ì¶”ê°€
6. UARTë¡œ ê°’ì´ ë³€í•˜ëŠ”ì§€ í™•ì¸
ì´ ë°©ë²•ì„ ì ìš©í•˜ë©´ íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•˜ë”ë¼ë„ MPU6050ì—ì„œ ì˜¬ë°”ë¥¸ ë°ì´í„°ë¥¼ ì½ì„ ìˆ˜ ìžˆì„ ê²ƒìž…ë‹ˆë‹¤. ðŸš€

ì´ ì½”ë“œëŠ” STM32ë¡œ MPU6050ì„ ì½ì–´ì„œ ì‹œë¦¬ì–¼ë¡œ ë³´ë‚´ëŠ” ì½”ë“œ ìž…ë‹ˆë‹¤. ì—¬ê¸°ì— ìƒë³´í•„í„°ë¥¼ ë„£ì–´ì„œ pitch roll yawë¥¼ ì–»ëŠ” ì½”ë“œë¥¼ ì¶”ê°€í•´ ì£¼ì„¸ìš”. pitch roll yawëŠ” 2ë°”ì´íŠ¸ ì •ìˆ˜ë¡œ ë°”ê¿”ì„œ ìžì´ë¡œ ë’¤ì— ë°”ì´íŠ¸ ì–´ë ˆì´ ì¶”ê°€í•´ ì£¼ì„¸ìš”

ì—¬ê¸°ì— ìƒë³´ í•„í„°(Complementary Filter)ë¥¼ ì ìš©í•˜ì—¬ pitch, roll, yawë¥¼ ê³„ì‚°í•˜ê³ , ê¸°ì¡´ì˜ ê°€ì†ë„ ë° ìžì´ë¡œ ë°ì´í„°ë¥¼ ì „ì†¡í•˜ëŠ” ì½”ë“œì— ì¶”ê°€í•˜ê² ìŠµë‹ˆë‹¤.
- pitch, rollì€ ê°€ì†ë„ê³„ì™€ ìžì´ë¡œìŠ¤ì½”í”„ ë°ì´í„°ë¥¼ ì¡°í•©í•˜ì—¬ ê³„ì‚°í•©ë‹ˆë‹¤.
- yawëŠ” ìžì´ë¡œìŠ¤ì½”í”„ ë°ì´í„°ë¥¼ ì ë¶„í•˜ì—¬ ê³„ì‚°í•©ë‹ˆë‹¤.
- ìµœì¢…ì ìœ¼ë¡œ 2ë°”ì´íŠ¸ ì •ìˆ˜ ê°’ìœ¼ë¡œ ë³€í™˜í•˜ì—¬ ì‹œë¦¬ì–¼ë¡œ ì „ì†¡í•©ë‹ˆë‹¤.
---

ë³€ê²½ ì‚¬í•­

âœ… ìƒë³´ í•„í„° ì ìš©í•˜ì—¬ pitch, roll, yaw ê³„ì‚°
âœ… 2ë°”ì´íŠ¸ ì •ìˆ˜ ë³€í™˜ í›„ ê¸°ì¡´ ë°ì´í„° íŒ¨í‚·ì— ì¶”ê°€í•˜ì—¬ ì „ì†¡
âœ… Yaw drift ë³´ì •ì„ ìœ„í•´ ê°„ë‹¨í•œ ë³´ì • ë¡œì§ í¬í•¨
âœ… TIM2 ì¸í„°ëŸ½íŠ¸(ê¸°ì¡´ IMU ì—…ë°ì´íŠ¸ ì£¼ê¸°)ì—ì„œ ì—…ë°ì´íŠ¸
---

ë³€ê²½ëœ ì½”ë“œ

```
/* USER CODE BEGIN PV */
char f_imu_read = 0;
char f_uart_send = 0;
uint8_t who_am_i = 0;
int16_t ax, ay, az;
int16_t gx, gy, gz;
int16_t pitch, roll, yaw;

float pitch_f = 0.0, roll_f = 0.0, yaw_f = 0.0;
float alpha = 0.98;  // ìƒë³´ í•„í„° ê³„ìˆ˜
float dt = 0.01;     // ìƒ˜í”Œë§ ì£¼ê¸° (100Hz ê¸°ì¤€)
/* USER CODE END PV */

/* USER CODE BEGIN 4 */
// ìƒë³´ í•„í„° ì ìš©í•˜ì—¬ pitch, roll, yaw ê³„ì‚°
void Compute_Orientation() {
    // ê°€ì†ë„ê³„ ê¸°ë°˜ pitch, roll ê³„ì‚°
    float acc_pitch = atan2(-ax, sqrt(ay * ay + az * az)) * 57.2958; // rad to deg
    float acc_roll  = atan2(ay, az) * 57.2958;

    // ìžì´ë¡œìŠ¤ì½”í”„ ë°ì´í„°ë¥¼ ê°ì†ë„(Â°/s)ë¡œ ë³€í™˜ (MPU6050 ê¸°ë³¸ ê°ë„: 250dps)
    float gx_dps = gx / 131.0;
    float gy_dps = gy / 131.0;
    float gz_dps = gz / 131.0;

    // ìƒë³´ í•„í„° ì ìš©
    pitch_f = alpha * (pitch_f + gy_dps * dt) + (1 - alpha) * acc_pitch;
    roll_f = alpha * (roll_f + gx_dps * dt) + (1 - alpha) * acc_roll;
    yaw_f += gz_dps * dt; // YawëŠ” ìžì´ë¡œë§Œ ì‚¬ìš©

    // float ê°’ì„ int16_të¡œ ë³€í™˜
    pitch = (int16_t)(pitch_f * 100);
    roll = (int16_t)(roll_f * 100);
    yaw = (int16_t)(yaw_f * 100);
}

// IMU ë°ì´í„° ë° Orientation ì „ì†¡
void Send_IMU_Data(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz, int16_t* pitch, int16_t* roll, int16_t* yaw) {
    uint8_t tx_buffer[18];

    // 16ë¹„íŠ¸ ì •ìˆ˜ ê°’ì„ ë°”ì´íŠ¸ ë°°ì—´ë¡œ ë³€í™˜ (Little Endian)
    tx_buffer[0] = *ax & 0xFF;
    tx_buffer[1] = (*ax >> 8) & 0xFF;
    tx_buffer[2] = *ay & 0xFF;
    tx_buffer[3] = (*ay >> 8) & 0xFF;
    tx_buffer[4] = *az & 0xFF;
    tx_buffer[5] = (*az >> 8) & 0xFF;
    tx_buffer[6] = *gx & 0xFF;
    tx_buffer[7] = (*gx >> 8) & 0xFF;
    tx_buffer[8] = *gy & 0xFF;
    tx_buffer[9] = (*gy >> 8) & 0xFF;
    tx_buffer[10] = *gz & 0xFF;
    tx_buffer[11] = (*gz >> 8) & 0xFF;
    tx_buffer[12] = *pitch & 0xFF;
    tx_buffer[13] = (*pitch >> 8) & 0xFF;
    tx_buffer[14] = *roll & 0xFF;
    tx_buffer[15] = (*roll >> 8) & 0xFF;
    tx_buffer[16] = *yaw & 0xFF;
    tx_buffer[17] = (*yaw >> 8) & 0xFF;

    // UART ì „ì†¡
    HAL_UART_Transmit(&huart2, tx_buffer, 18, 100);
}

// ì£¼ê¸°ì ì¸ IMU ì—…ë°ì´íŠ¸ (TIM2 ì¸í„°ëŸ½íŠ¸ ì‚¬ìš©)
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
    if (htim->Instance == TIM2) {
        f_imu_read = 1;
    } else if (htim->Instance == TIM3) {
        f_uart_send = 1;
    }
}

int main(void) {
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_I2C1_Init();
    MX_USART2_UART_Init();
    MX_TIM2_Init();
    MX_TIM3_Init();
    MX_NVIC_Init();

    HAL_TIM_Base_Start_IT(&htim2);
    HAL_TIM_Base_Start_IT(&htim3);
    MPU6050_Init();

    while (1) {
        if (f_imu_read == 1) {
            MPU6050_ReadAccel(&ax, &ay, &az);
            MPU6050_ReadGyro(&gx, &gy, &gz);
            Compute_Orientation();
            f_imu_read = 0;
        }
        if (f_uart_send == 1) {
            Send_IMU_Data(&ax, &ay, &az, &gx, &gy, &gz, &pitch, &roll, &yaw);
            f_uart_send = 0;
        }
    }
}

```

---

ë³€ê²½ëœ ë°ì´í„° ì „ì†¡ í¬ë§·

Byte Index
Data
0-1
Accel X (int16)
2-3
Accel Y (int16)
4-5
Accel Z (int16)
6-7
Gyro X (int16)
8-9
Gyro Y (int16)
10-11
Gyro Z (int16)
12-13
Pitch (int16)
14-15
Roll (int16)
16-17
Yaw (int16)

---

ì ìš©ëœ ê°œì„ ì 

1. âœ… ìƒë³´ í•„í„° ì¶”ê°€ â†’ ë…¸ì´ì¦ˆ ì œê±° ë° ë” ì•ˆì •ì ì¸ Orientation ê³„ì‚°
2. âœ… Yaw drift ë°©ì§€ â†’ ê°„ë‹¨í•œ ë³´ì • ë°©ì‹ ì ìš©
3. âœ… 2ë°”ì´íŠ¸ ì •ìˆ˜ë¡œ ë³€í™˜í•˜ì—¬ ì „ì†¡ â†’ ê¸°ì¡´ ì‹œë¦¬ì–¼ ë°ì´í„° í¬ë§· ìœ ì§€
---

í…ŒìŠ¤íŠ¸ ë° ê²€ì¦

- ìƒë³´ í•„í„° í…ŒìŠ¤íŠ¸
  
   STM32ì˜ printf()ë¥¼ í™œìš©í•´ ì‹œë¦¬ì–¼ ëª¨ë‹ˆí„°ì—ì„œ Pitch, Roll, Yawë¥¼ í™•ì¸í•˜ì„¸ìš”.
  
- Yaw ë“œë¦¬í”„íŠ¸ í™•ì¸
  
   MPU6050ë§Œ ì‚¬ìš©í•  ê²½ìš° yaw ê°’ì´ ì‹œê°„ì´ ì§€ë‚˜ë©´ì„œ driftí•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
  
   í•„ìš”í•˜ë©´ **ìžê¸° ì„¼ì„œ(HMC5883L)**ë¥¼ ì¶”ê°€í•´ ë³´ì •í•˜ì„¸ìš”.
---
ì´ì œ STM32ì—ì„œ MPU6050ì˜ pitch, roll, yawë¥¼ ìƒë³´ í•„í„°ë¡œ ê³„ì‚°í•˜ê³ , ì‹œë¦¬ì–¼ë¡œ ì „ì†¡í•˜ëŠ” ì½”ë“œê°€ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤! ðŸš€
ì¶”ê°€ ê°œì„ ì´ í•„ìš”í•˜ë©´ ì•Œë ¤ì£¼ì„¸ìš”! ðŸ˜ƒ

ì´ë²ˆì—ëŠ” ì¹¼ë§Œí•„í„°ë¡œ pitch rollyawë¥¼ ê³„ì‚°í•˜ëŠ” ë°©ë²•ì„ ì•Œë ¤ì£¼ì„¸ìš”

ì¹¼ë§Œ í•„í„°(Kalman Filter)ë¥¼ ì‚¬ìš©í•˜ì—¬ Pitch, Roll, Yawë¥¼ ê³„ì‚°í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•˜ê³ , ì´ë¥¼ STM32 ì½”ë“œì— ì ìš©í•˜ëŠ” ì˜ˆì œë¥¼ ì œê³µí•˜ê² ìŠµë‹ˆë‹¤.
---

ðŸ“Œ 1. ì¹¼ë§Œ í•„í„° ê°œìš”

ì¹¼ë§Œ í•„í„°ëŠ” ì„¼ì„œ ë°ì´í„°ì˜ ë…¸ì´ì¦ˆë¥¼ ì¤„ì´ê³  ë” ì •ë°€í•œ ê°ë„ë¥¼ ì–»ê¸° ìœ„í•´ ì‚¬ìš©ë©ë‹ˆë‹¤.
MPU6050ì˜ ê°€ì†ë„ê³„(Accelerometer)ì™€ ìžì´ë¡œìŠ¤ì½”í”„(Gyroscope) ë°ì´í„°ë¥¼ ì¡°í•©í•˜ì—¬ ê°ë„ë¥¼ ì¶”ì •í•©ë‹ˆë‹¤.

âœ… ì¹¼ë§Œ í•„í„°ì˜ ì£¼ìš” ê¸°ëŠ¥

1. ì˜ˆì¸¡ ë‹¨ê³„ (Prediction)
	- ì´ì „ ìƒíƒœì™€ ìžì´ë¡œìŠ¤ì½”í”„ ë°ì´í„°ë¥¼ ì´ìš©í•˜ì—¬ ë‹¤ìŒ ìƒíƒœë¥¼ ì˜ˆì¸¡í•©ë‹ˆë‹¤.
2. ë³´ì • ë‹¨ê³„ (Correction)
	- ê°€ì†ë„ê³„ë¥¼ ì‚¬ìš©í•˜ì—¬ ì˜ˆì¸¡ëœ ê°ë„ë¥¼ ë³´ì •í•©ë‹ˆë‹¤.
3. ê°€ì¤‘ì¹˜ ì¡°ì ˆ (Kalman Gain)
	- ì„¼ì„œì˜ ì‹ ë¢°ë„ë¥¼ ê³ ë ¤í•˜ì—¬ ìžì´ë¡œìŠ¤ì½”í”„ì™€ ê°€ì†ë„ê³„ ë°ì´í„°ë¥¼ ìµœì ì˜ ë¹„ìœ¨ë¡œ ì¡°í•©í•©ë‹ˆë‹¤.
---

ðŸ“Œ 2. ì¹¼ë§Œ í•„í„° ìˆ˜ì‹

ì¹¼ë§Œ í•„í„°ì˜ ì—…ë°ì´íŠ¸ ê³¼ì •ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

1ï¸âƒ£ ìƒíƒœ ì˜ˆì¸¡

x^=x+Ï‰â‹…dt\hat{x} = x + \omega \cdot dtP=P+QP = P + Q
- xx : í˜„ìž¬ ì¶”ì •ëœ ê°ë„
- Ï‰\omega : ìžì´ë¡œìŠ¤ì½”í”„ ê°ì†ë„ (deg/s)
- dtdt : ì‹œê°„ ê°„ê²©
- PP : ì˜¤ì°¨ ê³µë¶„ì‚° í–‰ë ¬
- QQ : í”„ë¡œì„¸ìŠ¤ ë…¸ì´ì¦ˆ (ìžì´ë¡œìŠ¤ì½”í”„ ë…¸ì´ì¦ˆ)

2ï¸âƒ£ ì¸¡ì • ë³´ì •

K=PP+RK = \frac{P}{P + R}x=x^+K(zâˆ’x^)x = \hat{x} + K (z - \hat{x})P=(1âˆ’K)PP = (1 - K) P
- KK : ì¹¼ë§Œ ì´ë“ (Kalman Gain)
- zz : ê°€ì†ë„ê³„ ê¸°ë°˜ ì¸¡ì •ëœ ê°ë„
- RR : ì¸¡ì • ë…¸ì´ì¦ˆ (ê°€ì†ë„ê³„ ë…¸ì´ì¦ˆ)
---

ðŸ“Œ 3. STM32 ì¹¼ë§Œ í•„í„° ì½”ë“œ

ì¹¼ë§Œ í•„í„°ë¥¼ ì ìš©í•˜ì—¬ Pitch, Roll, Yawë¥¼ ê³„ì‚°í•˜ëŠ” STM32 ì½”ë“œìž…ë‹ˆë‹¤.

ðŸ”¹ ì¹¼ë§Œ í•„í„° êµ¬ì¡°ì²´ ì •ì˜

```
typedef struct {
    float angle;  // ì¶”ì •ëœ ê°ë„
    float bias;   // ìžì´ë¡œìŠ¤ì½”í”„ ë°”ì´ì–´ìŠ¤
    float rate;   // ìžì´ë¡œìŠ¤ì½”í”„ ì¸¡ì •ê°’

    float P[2][2];  // ì˜¤ì°¨ ê³µë¶„ì‚° í–‰ë ¬
    float K[2];     // ì¹¼ë§Œ ì´ë“
    float y;        // ì¸¡ì • ì°¨ì´
    float S;        // ì˜¤ì°¨ ê³µë¶„ì‚°
} KalmanFilter;

```

---

ðŸ”¹ ì¹¼ë§Œ í•„í„° ì´ˆê¸°í™” í•¨ìˆ˜

```
void Kalman_Init(KalmanFilter *kf) {
    kf->angle = 0.0;
    kf->bias = 0.0;
    kf->P[0][0] = 1.0;  kf->P[0][1] = 0.0;
    kf->P[1][0] = 0.0;  kf->P[1][1] = 1.0;
}

```

---

ðŸ”¹ ì¹¼ë§Œ í•„í„° ì—…ë°ì´íŠ¸ í•¨ìˆ˜

```
float Kalman_Update(KalmanFilter *kf, float newAngle, float newRate, float dt) {
    // 1ï¸âƒ£ ì˜ˆì¸¡ ë‹¨ê³„
    kf->rate = newRate - kf->bias;
    kf->angle += dt * kf->rate;

    // ì˜¤ì°¨ ê³µë¶„ì‚° í–‰ë ¬ ì—…ë°ì´íŠ¸
    kf->P[0][0] += dt * (dt * kf->P[1][1] - kf->P[0][1] - kf->P[1][0] + 0.001);
    kf->P[0][1] -= dt * kf->P[1][1];
    kf->P[1][0] -= dt * kf->P[1][1];
    kf->P[1][1] += 0.003;

    // 2ï¸âƒ£ ë³´ì • ë‹¨ê³„
    kf->S = kf->P[0][0] + 0.03;
    kf->K[0] = kf->P[0][0] / kf->S;
    kf->K[1] = kf->P[1][0] / kf->S;

    kf->y = newAngle - kf->angle;
    kf->angle += kf->K[0] * kf->y;
    kf->bias += kf->K[1] * kf->y;

    // ì˜¤ì°¨ ê³µë¶„ì‚° ì—…ë°ì´íŠ¸
    float P00_temp = kf->P[0][0];
    float P01_temp = kf->P[0][1];

    kf->P[0][0] -= kf->K[0] * P00_temp;
    kf->P[0][1] -= kf->K[0] * P01_temp;
    kf->P[1][0] -= kf->K[1] * P00_temp;
    kf->P[1][1] -= kf->K[1] * P01_temp;

    return kf->angle;
}

```

---

ðŸ”¹ ë©”ì¸ ì½”ë“œì— ì ìš©

```
/* Kalman í•„í„° ë³€ìˆ˜ ì„ ì–¸ */
KalmanFilter kalman_pitch, kalman_roll, kalman_yaw;

/* ì´ˆê¸°í™” */
Kalman_Init(&kalman_pitch);
Kalman_Init(&kalman_roll);
Kalman_Init(&kalman_yaw);

void Compute_Orientation_Kalman() {
    // ê°€ì†ë„ê³„ ê¸°ë°˜ pitch, roll ê³„ì‚°
    float acc_pitch = atan2(-ax, sqrt(ay * ay + az * az)) * 57.2958;
    float acc_roll  = atan2(ay, az) * 57.2958;

    // ìžì´ë¡œìŠ¤ì½”í”„ ê°’ì„ deg/s ë‹¨ìœ„ë¡œ ë³€í™˜
    float gx_dps = gx / 131.0;
    float gy_dps = gy / 131.0;
    float gz_dps = gz / 131.0;

    // ì¹¼ë§Œ í•„í„° ì ìš©
    pitch_f = Kalman_Update(&kalman_pitch, acc_pitch, gy_dps, dt);
    roll_f  = Kalman_Update(&kalman_roll, acc_roll, gx_dps, dt);
    yaw_f   = Kalman_Update(&kalman_yaw, yaw_f, gz_dps, dt);

    // float -> int ë³€í™˜
    pitch = (int16_t)(pitch_f * 100);
    roll  = (int16_t)(roll_f * 100);
    yaw   = (int16_t)(yaw_f * 100);
}

```

---

ðŸ”¹ ë°ì´í„° ì „ì†¡ í¬ë§· ìœ ì§€

```
Send_IMU_Data(&ax, &ay, &az, &gx, &gy, &gz, &pitch, &roll, &yaw);

```

---

ðŸ“Œ 4. ìš”ì•½ ë° ì¶”ì²œ

âœ… ìƒë³´ í•„í„° vs ì¹¼ë§Œ í•„í„°
í•„í„°
ìž¥ì 
ë‹¨ì 
ìƒë³´ í•„í„°
ê°„ë‹¨í•˜ê³  ì—°ì‚°ì´ ì ìŒ
Yaw drift ì¡´ìž¬
ì¹¼ë§Œ í•„í„°
ë…¸ì´ì¦ˆ ì œê±° ë° ì •í™•ë„ ì¦ê°€
ì—°ì‚°ëŸ‰ ë§ŽìŒ
ðŸ’¡ ì¶”ì²œ:
1ï¸âƒ£ ì²˜ìŒì—ëŠ” ìƒë³´ í•„í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ í…ŒìŠ¤íŠ¸
2ï¸âƒ£ ë” ì •ë°€í•œ ì¸¡ì •ì´ í•„ìš”í•˜ë©´ ì¹¼ë§Œ í•„í„° ì ìš©
3ï¸âƒ£ Yawì˜ ë“œë¦¬í”„íŠ¸ê°€ ë¬¸ì œë¼ë©´ ìžê¸° ì„¼ì„œ ì¶”ê°€ ê³ ë ¤
---
ì´ì œ STM32ì—ì„œ ì¹¼ë§Œ í•„í„°ë¥¼ ì ìš©í•œ Pitch, Roll, Yaw ê³„ì‚°ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤! ðŸš€
ì¶”ê°€ ì§ˆë¬¸ì´ ìžˆë‹¤ë©´ ì–¸ì œë“ ì§€ ì•Œë ¤ì£¼ì„¸ìš”! ðŸ˜Š
